<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Web组件(Web Components) | HTML5 | 盖世小虫</title>
  <meta name="author" content="suetming">
  
  <meta name="description" content="译者：suetming
原文：W3C: Web Components
SuetMing 保留部分权力。基于“CC 3.0 BY-SA 协议”发布
1 关于本文
注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.这是一个迭代的过程
本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明">
  
  <meta name="keywords" content="javascript,shadow DOM,templates,decorator,import,custom elements">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Web组件(Web Components) | HTML5"/>
  <meta property="og:site_name" content="盖世小虫"/>

  
    <meta property="og:image" content="undefined"/>
  

  <meta name="ujianVerification" content="c7a5b14d01398b6bf2275703e3accf06" />
  <meta name="baidu-site-verification" content="8a5djZlscm" />
  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="盖世小虫" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40716915-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">盖世小虫</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="http://essays.suetming.com">糗事与观点</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-07-29T13:57:45.000Z"><a href="/2014/07/29/2013-06-29-web-components/">7月 29 2014</a></time>
      
      
  
    <h1 class="title">Web组件(Web Components) | HTML5</h1>
  

    </header>
    <div class="entry">
      
        <p>译者：<a href="http://suetming.com" target="_blank" rel="external">suetming</a></p>
<p>原文：<a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/" target="_blank" rel="external">W3C: Web Components</a></p>
<p><strong>SuetMing 保留部分权力。基于“<a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="external">CC 3.0 BY-SA 协议</a>”发布</strong></p>
<h2 id="1_关于本文">1 关于本文</h2>
<p>注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.<br>这是一个迭代的过程</p>
<p>本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明</p>
<p><a id="more"></a></p>
<h2 id="2_介绍">2 介绍</h2>
<p>web组件模型由5部分组成：</p>
<ul>
<li>Templates：由一系列复用时能被激活的标记组成</li>
<li>Decorators：用于Templates中，通过CSS丰富和控制交互改变文本</li>
<li>Custom Elements：让用户可以自定义元素[自定义元素名、自定义API接口]</li>
<li>Shadow DOM：将一组DOM树封装成一个用户接口元素</li>
<li>Imports：定义如何将Templates、Decorators和Custom Elements打包，并且能够以资源的形式从外部引用</li>
</ul>
<p>每一部分都有各自的用途. 如果将这5种技术引入，开发人员可以轻松的编写拥有复杂交互体验的组件，并且可以轻松引用和组装，这是今天的CSS和脚本语言所无法达到的</p>
<p>本文将会讨论这5种技术，并举例说明其在Web组件中的作用</p>
<h2 id="3_Templates">3 Templates</h2>
<p>具体规范参加这篇<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html" target="_blank" rel="external">HTML Templates</a></p>
<p><strong>template</strong>元素及其所包含元素会由解析器进行解析并标记，不过不会立即渲染出来，脚本不会立即执行，包含的图片也不会立即下载</p>
<p><strong>template</strong>元素有一个属性 <strong>content</strong> 存储元素的实际内容，属性 <strong>content</strong> 的内容可以拷贝移动到HTML节点中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag"><<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"commentTemplate"</span>></span>
    <span class="tag"><<span class="title">div</span>></span>
        <span class="tag"><<span class="title">img</span> <span class="attribute">src</span>=<span class="value">""</span>></span>
        <span class="tag"><<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"comment-text"</span>></span><span class="tag"></<span class="title">div</span>></span>
    <span class="tag"></<span class="title">div</span>></span>
<span class="tag"></<span class="title">template</span>></span>
<span class="tag"><<span class="title">script</span>></span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">addComment</span><span class="params">(imageUrl, text)</span> {</span>
  <span class="keyword">var</span> t = document.querySelector(<span class="string">"#commentTemplate"</span>);
  <span class="keyword">var</span> comment = t.content.cloneNode(<span class="literal">true</span>);
  <span class="comment">// Populate content.</span>
  comment.querySelector(<span class="string">'img'</span>).src = imageUrl;
  comment.querySelector(<span class="string">'.comment-text'</span>).textContent = text;
  document.body.appendChild(comment);
}
</span><span class="tag"></<span class="title">script</span>></span>
</pre></td></tr></table></figure>

<p><strong>template</strong> 所包含的的元素包含在属性 <strong>content</strong> 中，通过script拷贝里面的元素并插入到HTML中使图片加载进来，脚本开始运行. 例如，在templates引入大型脚本，需要时调用</p>
<h2 id="4_Decorators">4 Decorators</h2>
<p>Decorators 目前没有标准文档，<strong>decorator</strong> 主要加强或者重载已经存在的元素，由CSS控制表现，与一般元素不同的是通过标记可以达到额外的效果</p>
<p><figure class="highlight <decorator>```通过包含```<template>```来明确具体渲染哪一块"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html</p>
<decorator id="details-open"><br>    <template><br>        <a id="summary"><br>          ▾<br>          <content select="summary"></content><br>        </a><br>        <content></content><br>    </template><br></decorator><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure><content><figure class="highlight 包含待渲染的内容，通过CSS控制生效"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>css<br>details[open] {<br>    decorator: url(#details-open);<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
通过这种方式可以使下面的html代码
</pre></td></tr></table></figure>html<br><details open><br>    <summary>Timepieces</summary><br>    <ul><br>      <li>Sundial<br>      </li><li>Cuckoo clock<br>      </li><li>Wristwatch<br>    </li></ul><br></details><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>
最终渲染成

<span class="xml"><span class="tag"><<span class="title">a</span>></span></span>
  ▾ Timepieces
<span class="xml"><span class="tag"></<span class="title">a</span>></span></span>
<span class="xml"><span class="tag"><<span class="title">ul</span>></span></span>
  <span class="xml"><span class="tag"><<span class="title">li</span>></span></span>Sundial
  <span class="xml"><span class="tag"></<span class="title">li</span>></span></span><span class="xml"><span class="tag"><<span class="title">li</span>></span></span>Cuckoo clock
  <span class="xml"><span class="tag"></<span class="title">li</span>></span></span><span class="xml"><span class="tag"><<span class="title">li</span>></span></span>Wristwatch
<span class="xml"><span class="tag"></<span class="title">li</span>></span></span><span class="xml"><span class="tag"></<span class="title">ul</span>></span></span>


<span class="strong">__decorator__</span> CSS属性可以指向任何网络资源，不过只有其“定义”被调用才能申请，生成的标记仅限于展示，永远不会运行脚本包括内联事件，而且也是不可编辑的

4.1 Decorators的事件

Decorators可以关联事件增强交互，decorator采用事件控制器当做媒介，因为decorator可能在任何时间生效或者失效，所以关联template中监听节点事件或者获取其状态都是无效的

![<span class="link_label">事件注册</span>](<span class="link_url">http://www.w3.org/TR/2013/WD-components-intro-20130606/event-handler-registration.png</span>)

通过事件控制器注册事件监听器，template中插入<span class="strong">__script__</span>，decorator元素插入到文档中时脚本会执行，脚本会被插入到注册队列中:
</pre></td></tr></table></figure>html<br><decorator id="details-open"><br>    <script><br>        function clicked(event) {<br>            event.target.removeAttribute(‘open’);<br>        }<br>        [{selector: ‘#summary’, type: ‘click’, handler: clicked}];<br>    </script><br>    <template><br>      <a id="summary"><br>        <!-- as illustrated above --><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
事件控制器解析注册事件如图所示

![<span class="link_label">事件的路由和重定向</span>](<span class="link_url">http://www.w3.org/TR/2013/WD-components-intro-20130606/event-routing-retargeting.png</span>)

事件监听器被调用时，事件的目标是最终生成的内容而不是template中的内容. 点击template中定义的▾，将会调用单击事件（在template中定义的<span class="strong">__\#summary__</span>元素）, event.target指向
</pre></td></tr></table></figure><details><figure class="highlight ，事件的重定向不会影响文档DOM结构"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
移除属性<span class="strong">__open__</span>，由于selector与decorator的属性不匹配，这个decorator不再有效. 未应用的decorator会回到最初的状态. 不过可以再构造一个decorator来渲染<span class="strong">__closed__</span>，通过激活不同的decorator可以达到无状态交互，代码如下
</pre></td></tr></table></figure>html<br><style><br>details {<br>    decorator: url(#details-closed);<br>}<br>details[open] {<br>    decorator: url(#details-open);<br>}<br></style><br><br><decorator id="details-closed"><br>    <script><br>        function clicked(event) {<br>            event.target.setAttribute(‘open’, ‘open’);<br>        }<br>        [{selector: ‘#summary’, type: ‘click’, handler: clicked}];<br>    </script><br>    <template><br>        <a id="summary"><br>            ▸ <content select="summary"></content><br>        </a><br>    </template><br></decorator>

<p><decorator id="details-open"><br>    <!-- as illustrated above --></decorator></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>
<span class="header">5 Custom Elements
----------------------------</span>

技术规范见此[<span class="link_label">The Custom Elements specification</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html</span>)

用户可以构造新的DOM元素，这种技术称之为Custom Elements. 不像decorators，自定义元素可以封装状态并提供脚本接口. 下面的数据表表明两者区别
</pre></td></tr></table></figure>html</p>
<p><blockquote></blockquote></p>
<p><table><br>   <tr><br>      <td></td><br>      <td>Decorators</td><br>      <td>Custom Elements</td><br>   </tr><br>   <tr><br>      <td>Lifetime</td><br>      <td>Ephemeral, while a CSS selector matches</td><br>      <td>Stable, matches entire element lifetime</td><br>   </tr><br>   <tr><br>      <td>Applied, unapplied dynamically</td><br>      <td>Yes, based on CSS selectors</td><br>      <td>No, fixed at element creation time</td><br>   </tr><br>   <tr><br>      <td>Accessible through script</td><br>      <td>No, transparent to DOM; cannot add interfaces</td><br>      <td>Yes, accessible through DOM; can provide interfaces</td><br>   </tr><br>   <tr><br>      <td>State</td><br>      <td>Stateless projection</td><br>      <td>Stateful DOM object</td><br>   </tr><br>   <tr><br>      <td>Behavior</td><br>      <td>Simulated by changing decorators</td><br>      <td>First-class using script and events</td><br>   </tr><br></table><br></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="header">5.1 构造一个自定义元素
-------------------------------------------</span>
用
</pre></td></tr></table></figure><element><figure class="highlight 构造一个元素，并指明继承哪一个属性如下："><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html</element></p>
<element extends="button" name="fancy-button"><br>    …<br></element><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>
<span class="strong">__extends__</span>属性标记继承于哪一个元素，自定义元素实例会有此标记名

<span class="strong">__name__</span>属性指明元素名称，命名必须包含“-”

用户的自定义元素应该继承最接近自己想法的实际存在的元素. 如果用户构造不继承任何元素的自定义元素，user agent会抛出异常[<span class="link_label">HTMLUnknownElement</span>](<span class="link_url">http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#htmlunknownelement</span>)

<span class="header">5.2 方法和属性
---------------</span>
将
</pre></td></tr></table></figure><script><figure class="highlight 插入到自定义元素中可以对自定义元素增加方法和属性，下面的例子中元素```<tick-tock-clock>```增加了tick方法"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html<br><element name="tick-tock-clock"><br>  <script><br>    ({<br>      tick: function () {<br>        …<br>      }<br>    });<br>  </script><br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>
5.3 生命周期回调函数
自定义元素有很多回调函数如下：

-<span class="ruby"> readyCallback：创建时调用
</span>-<span class="ruby"> insertedCallback：插入文档时调用
</span>-<span class="ruby"> removedCallbakc：删除元素时调用
</span>
下面的例子演示如何用template，Shadow DOM (见下一章节)，以及Custom Elements回调函数创建元素：
</pre></td></tr></table></figure>html<br><element name="tick-tock-clock"><br>  <template><br>    <span id="hh"></span><br>    <span id="sep">:</span><br>    <span id="mm"></span><br>  </template><br>  <script><br>    var template = document.currentScript.parentNode.querySelector(‘template’);<br><br>    function start() {<br>      this.tick();<br>      this._interval = window.setInterval(this.tick.bind(this), 1000);<br>    }<br>    function stop() {<br>      window.clearInterval(this._interval);<br>    }<br>    function fmt(n) {<br>      return (n &lt; 10 ? ‘0’ : ‘’) + n;<br>    }<br><br>    ({<br>      readyCallback: function () {<br>        this._root = this.createShadowRoot();<br>        this._root.appendChild(template.content.cloneNode());<br>        if (this.parentElement) {<br>          start.call(this);<br>        }<br>      },<br>      insertedCallback: start,<br>      removedCallback: stop,<br>      tick: function () {<br>        var now = new Date();<br>        this._root.querySelector(‘hh’).textContent = fmt(now.getHours());<br>        this._root.querySelector(‘sep’).style.visibility =<br>            now.getSeconds() % 2 ? ‘visible’ : ‘hidden’;<br>        this._root.querySelector(‘mm’).textContent = fmt(now.getMinutes());<br>      },<br>      chime: function () { … }<br>    });<br>  </script><br></element><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
<span class="number">5.4</span> Custom Elements实例化
自定义元素均继承HTML的标准元素(div/button/option/<span class="keyword">...</span>)， 当用户想用这些元素的时候需要用到属性__is__，如下：
</pre></td></tr></table></figure>html<br><element extends="button" name="fancy-button">  <!-- definition --><br>    …<br></element>

<p><button is="fancy-button">  <!-- use --><br>    Do something fancy<br></button></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
5.5 Script实例化Custom Elements
通过脚本语言也可以实例化自定义元素，方法为<span class="strong">__register__</span>，具体见下述代码：
</pre></td></tr></table></figure>javascript<br>var p = Object.create(HTMLButtonElement.prototype, {});<br>p.dazzle = function () { … };</p>
<p>// 返回实例化对象<br>var FancyButton = document.register(‘button’, ‘fancy-button’, {prototype: p});<br>var b = new FancyButton();<br>document.body.appendChild(b);<br>b.addEventListener(‘click’, function (event) {<br>    event.target.dazzle();<br>});</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
也可以直接通过createElement生成：
</pre></td></tr></table></figure>javascript<br>var b = document.createElement(‘button’, ‘fancy-button’);<br>alert(b.outerHTML); // will display ‘<button is="fancy-button"></button>‘<br>var c = document.createElement(‘tick-tock-clock’);<br>alert(c.outerHTML); // will display ‘<tick-tock-clock></tick-tock-clock>‘</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="header">5.6 元素更新
---------------</span>
当元素定义调用的时候，每一个匹配的元素都会进行更新. 更新元素后，元素相应API会生效，生命周期相关函数会被调用.
通过CSS_<span class="emphasis">_:unresolved_</span><span class="emphasis">_可以匹配所有为构造的自定义元素，通过这种方式避免更新元素所造成的闪烁</span>
</pre></td></tr></table></figure>html</p>
<p><style><br>tick-tock-clock:unresolved {<br>  content: ‘??:??’;<br>}<br></style></p>
<p><tick-tock-clock></tick-tock-clock> <!-- will show ??:?? --></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
也可以通过脚本进行控制
</pre></td></tr></table></figure>javascript<br>// Chime ALL the clocks!<br>Array.prototype.forEach.call(<br>  document.querySelectorAll(‘tick-tock-clock:not(:unresolved)’),<br>  function (clock) { clock.chime(); });</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>通过自定义事件元素可以通知页面其他部分元素已经更新，可以等到元素更新完成，脚本在对其进行操作

<span class="number">5.7</span> 扩展<span class="keyword">Custom</span> Elements
元素也可以继承自定义元素，代码如下：
</pre></td></tr></table></figure>html</p>
<p><element extends="tick-tock-clock" name="grand-father-clock"><br>    …<br></element></p>
<script>
var p = Object.create(Object.getPrototypeOf(document.createElement('tick-tock-clock')));
p.popOutBirdie = function () { … }
var CuckooClock = document.register('cuckoo-clock', {prototype: p});
var c = new CuckooClock();
c.tick();         // inherited from tick-tock-clock
c.popOutBirdie(); // specific to cuckoo-clock
</script>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>
<span class="header">6 Shadow DOM
------------------------</span>
相应规范见这里[<span class="link_label">The Shadow DOM specification</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html</span>)

Shadow DOM 是一种DOM节点的辅助树. Shadow DOM 子树能够关联某个元素，但不会显示在元素子节点中，子树有自己的作用域. 例如，一个shadow DOM 子树可以和文档中相同ID和风格的元素而不冲突，因为shadow DOM 子树与文档是完全分离的

Shadow DOM 通过[<span class="link_label">__createShadowRoot__</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#api-partial-element-create-shadow-root</span>)方法生效，返回shadow DOM的根节点并填充到DOM节点中

![<span class="link_label">shadow trees</span>](<span class="link_url">http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg</span>)

<span class="xml"><span class="tag"><<span class="title">object</span> <span class="attribute">data</span>=<span class="value">"http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg"</span> <span class="attribute">width</span>=<span class="value">"800"</span> <span class="attribute">height</span>=<span class="value">"430"</span>></span></span><span class="xml"><span class="tag"></<span class="title">object</span>></span></span>

关联shadow DOM的元素称为[<span class="link_label">shadow host</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-shadow-host</span>). 当元素存在shadow DOM，元素的子节点不会渲染；渲染的是shadow DOM的内容

![<span class="link_label">shadow rendering</span>](<span class="link_url">http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg</span>)

<span class="xml"><span class="tag"><<span class="title">object</span> <span class="attribute">data</span>=<span class="value">"http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg"</span> <span class="attribute">width</span>=<span class="value">"450"</span> <span class="attribute">height</span>=<span class="value">"400"</span>></span></span><span class="xml"><span class="tag"></<span class="title">object</span>></span></span>

6.1 插入点
shadow DOM 子树通过
</pre></td></tr></table></figure><content><figure class="highlight 元素作为渲染输出插入点."><figcaption><span>```<content>```只是作为渲染输出的插入点，如下：</content></span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html
<!-- document -->
<div id="news">
  <h1>Good day for kittens</h1>
  <div class="breaking">Kitten rescued from tree</div>
  <div>Area kitten "adorable"—owner</div>
  <div class="breaking">Jiggled piece of yarn derails kitten kongress</div>
</div>

<!-- #news' shadow -->
<template id="t">
  <content select="h1"></content>
  <div id="ticker">
    <content id="stories"></content>
  </div>
</template>

<!-- #ticker's shadow -->
<template id="u">
  <content class="highlight" select=".breaking"></content>
  <content></content>
</template>

<script>
// Set up shadow DOM
var news = document.querySelector('#news');
var r = news.createShadowRoot();
var t = document.querySelector('#t');
r.appendChild(t.content.cloneNode(true));

var ticker = r.querySelector('#ticker');
var s = ticker.createShadowRoot();
var u = document.querySelector('#u');
s.appendChild(u.content.cloneNode(true));
</script>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
理论上，第一部分文档和第一部分<span class="built_in">shadow</span>根节点生成了下面的DOM树. 宿主元素的子节点显示在插入点的位置.
</pre></td></tr></table></figure>html
<div id="news">
  <h1>Good day for kittens</h1>
  <div id="ticker">
    <div class="breaking">Kitten rescued from tree</div>
    <div>Area kitten "adorable"—owner</div>
    <div class="breaking">Jiggled piece of yarn derails kitten kongress</div>
  </div>
</div>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
第二部分，由于
</pre></td></tr></table></figure><content class="highlight" select=".breaking"><figure class="highlight 所有类属性为breaking的排在顶部，这种方式称为[reprojection](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#reprojection)"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html
<div id="news">
  <h1>Good day for kittens</h1>
  <div id="ticker">
    <div class="breaking">Kitten rescued from tree</div>
    <div class="breaking">Jiggled piece of yarn derails kitten kongress</div>
    <div>Area kitten "adorable"—owner</div>
  </div>
</div>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
6.3 备用内容
插入点可以有<span class="emphasis">_content_</span>，称为[<span class="link_label">备用内容</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-fallback-content</span>)，当插入点没有任何文本时，会显示此信息，如下：
</pre></td></tr></table></figure>html
<!-- #news' shadow -->
<template id="t">
  <content select="h1">Today's top headlines</content>
  <div id="ticker">
    <content id="stories">
      No news
      <button onclick="window.location.reload(true);">Reload</button>
    </content>
  </div>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="header">6.4 多重Shadow子树
---------------------------</span>
一个元素可以含有不止一个shadow DOM 子树. 继承一个已具有shadow DOM子树的自定义元素是很常见的. 不过要是想重用原先的元素时怎么处理? 如何重用?
利用
</pre></td></tr></table></figure><shadow><figure class="highlight 可以调用原先申请的shadow"><figcaption><span>DOM 子树，如下：</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html
<element name="sailing-watch" extends="tick-tock-clock">
  <template>
    <shadow></shadow>
    <div id="compass">N</div>
  </template>
  <script>
    …
  </script>
</element>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>
由于一个元素可以有多个shadow，我们需要了解这些shadow如何相互影响，如何作用元素的子节点

由于你不能删除shadow root，所以shadow DOM子树生效时的顺序很重要，如下：

-<span class="ruby"> <span class="number">1</span>. user agent shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">2</span>. 自定义元素的shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">3</span>. 第一个派生自定义元素的shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">4</span>. ...
</span>-<span class="ruby"> <span class="number">5</span>. 用脚本添加的<span class="constant">Ad</span>-hoc shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">6</span>. <span class="constant">Decorator</span> shadow (applied <span class="keyword">and</span> removed with <span class="constant">CSS</span> rules—<span class="keyword">not</span> technically shadow <span class="constant">DOM</span>, but its insertion points work similarly to shadow <span class="constant">DOM</span>.)
</span>
其次，根据顺序从最新生效的子树反向推倒，每一个
</pre></td></tr></table></figure><content><figure class="highlight 插入点，根据规则，可以定位任何宿主元素子节点"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
一旦子节点在正确的地方渲染，我们可以检查是否有
</pre></td></tr></table></figure><shadow><figure class="highlight 元素，如果没有，表明成功；如果有，从```<shadow>```队列元素中取出子树重复替换```<content>```插入点，直到队尾."><figcaption><span>具体见如下图：</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>
![<span class="link_label">shadow stack</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg</span>)

<span class="xml"><span class="tag"><<span class="title">object</span> <span class="attribute">data</span>=<span class="value">"https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg"</span> <span class="attribute">width</span>=<span class="value">"500"</span> <span class="attribute">height</span>=<span class="value">"600"</span>></span></span><span class="xml"><span class="tag"></<span class="title">object</span>></span></span>

总结一下：

<span class="bullet">- </span>最近申请的shadow DOM 子树最可能在
</pre></td></tr></table></figure><content><figure class="highlight 插入点获得最新的子树"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>-<span class="ruby"> 以此类推
</span>-<span class="ruby"> 直到当前的shadow <span class="constant">DOM</span>子树没有</span>
</pre></td></tr></table></figure><shadow><figure class="highlight ，那么其就是这个元素最后的DOM子树"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
<span class="header">6.5 CSS 和 Shadow DOM
-------------------------------------</span>
当构建自定义元素时自然要考虑属性、内容和API接口. 这与页面渲染同等重要. Shadow DOM 提供给开发者很多方式控制shadow DOM内容的样式.

shadow DOM 子树有一个不看见的边界，user agent的样式默认生效，而不是定制的样式. 派生的元素依旧有效，这不是我们想要的. 在上面的scailing-watch的例子里，如果页面内容被渲染成绿色，如果要保持整体风格，shadow DOM内的文本由于color属性由于继承性质也会是绿色，不过设定了所有
</pre></td></tr></table></figure><div><figure class="highlight 元素橙色边框，"><figcaption><span>那direction indicator不会有橙色边框因为__border__并不是具有继承性质的属性</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
一个shadow根节点有两个属性控制行为. applyAuthorStyles（开发者样式）属性，shadow DOM 会匹配最接近的样式，注意这个属性只能匹配shadow DOM 子树. 使用时要注意"n"代选择器

如果<span class="strong">__applyAuthorStyles__</span>设置为false，<span class="strong">__resetStyleInheritance__</span>设置为true，样式会清空. 元素会被与页面样式隔离，你可以通过浏览器重置样式

在插入点有相似的界限. shadow DOM子树的样式不会再插入点分布的元素上生效. 不过要是通过选择器想渲染某一部分特定内容， 可以用[<span class="link_label">::distributed pseudo-selector</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#distributed-pseudo-element</span>)，如下：
</pre></td></tr></table></figure>html
<!-- #ticker's shadow -->
<template id="u">
  <style>
    content::distributed(*) {
      display: inline-block;
    }
    *::distributed(.breaking) {
      text-shadow: 0 0 0.2em maroon;
      color: orange;
    }
  </style>
  <content class="highlight" select=".breaking"></content>
  <content></content>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
上述包含了两个规则，选择器的左半部分是<span class="built_in">shadow</span> DOM 生效；括号内代表适用元素。第一个选择器对
</pre></td></tr></table></figure><content><figure class="highlight 的所有元素有效；第二个选择器对类对象为breaking的元素有效"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
ShadowDOM 也可以定制宿主元素的样式. 代码如下：
</pre></td></tr></table></figure>html
<!-- #ticker's shadow -->
<template id="u">
  <style>
    @host {
      :scope {
        white-space: nowrap;
        overflow-style: marquee-line;
        overflow-x: marquee;
      }
    }
    content::distributed(*) {
      display: inline-block;
    }
    *::distributed(.breaking) {
      text-shadow: 0 0 0.2em maroon;
      color: orange;
    }
  </style>
  <content class="highlight" select=".breaking"></content>
  <content></content>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
最后，有两种方式可以使<span class="built_in">shadow</span> DOM 子树的样式与页面保持一致. 首先通过分配一个伪ID暴漏<span class="built_in">shadow</span> DOM 子树中的特定元素，开发者可以定制其样式. 例如：
</pre></td></tr></table></figure>html
<script>
// Set up shadow DOM
…
var ticker = r.querySelector('#ticker');
ticker.pseudo = 'x-ticker';
…
</script>

<p><!-- change the appearance of the ticker part --></p>
<p><style></p>
<h1 id="news::x-ticker_{">news::x-ticker {</h1>
<p>  background: gray;<br>  color: lightblue;<br>}<br></style></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
另一种方法是通过CSS变量进行控制，如下：
</pre></td></tr></table></figure>html<br><!-- #ticker's shadow --></p>
<template id="u"><br>  <style><br>    @host {<br>      :scope {<br>        white-space: nowrap;<br>        overflow-style: marquee-line;<br>        overflow-x: marquee;<br>      }<br>    }<br>    content::distributed(<em>) {<br>      display: inline-block;<br>    }
    </em>::distributed(.breaking) {<br>      text-shadow: 0 0 0.2em var(highlight-accent, maroon);<br>      color: var(highlight-primary, orange);<br>    }<br>  </style><br>  <content class="highlight" select=".breaking"></content><br>  <content></content><br></template>

<p><!-- change the appearance of the ticker part --></p>
<p><style></p>
<h1 id="news::x-ticker_{-1">news::x-ticker {</h1>
<p>  background: gray;<br>  color: lightblue;<br>  var-highlight-primary: green;<br>  var-highlight-accent: yellow;<br>}<br></style></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
伪元素方法针对特定元素保持页面样式非常有用，而CSS变量则对不想重复指定的属性集（主题风格）非常有用. 

<span class="header">6.6 Shadow DOM中的事件
----------------------------------------</span>
为了确保shadow DOM子树中的元素不会暴露给外部子树，会有很多工作来分发内部子树事件. 
首先，shadow DOM 子树会阻止事件如mutation和selectstart外部监听. 那些能够穿过shadow DOM的范围并且重定向的的事件，它们的_<span class="emphasis">_target_</span><span class="emphasis">_和_</span><span class="emphasis">_relatedTarget_</span><span class="emphasis">_的会指向shadow DOM子树的宿主元素. 在一些情况下，如_</span><span class="emphasis">_DOMFocusIn_</span><span class="emphasis">_，_</span><span class="emphasis">_mouseover_</span><span class="emphasis">_，_</span><span class="emphasis">_mouseout_</span><span class="emphasis">_事件需要特别注意，如果你在shadow DOM的两个元素中间移动鼠标，会出现鼠标从本身移动到它本身这种诡异的事件

</span>
<span class="header">7 Imports
----------------------------------------</span>
规范标准见这里[The HTML Imports specification](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html)

Custom elements 和 decorators可以通过文件的方式引入：
</pre></td></tr></table></figure>html</p>
<p><link rel="import" href="goodies.html"></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
只有
</pre></td></tr></table></figure><decorator><code>元素和</code><element>```能被user agent解析，脚本也可以通过<strong>import</strong>属性获取DOM.  跨域检索的文档可以通过CORS判定这些定义是否可以跨站运行. </element></decorator></p>
</content></div></shadow></content></shadow></content></shadow></content></content></details></a></template></decorator></content>
      
    </div>
    <footer>
      
        <strong style="text-color:#ff0000">转载本站文章请注明作者和出处 [盖世小虫-suetming.com],请勿用于任何商业目的</strong>
        
  
  <div class="categories">
    <a href="/categories/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/shadow-DOM/">shadow DOM</a>, <a href="/tags/templates/">templates</a>, <a href="/tags/decorator/">decorator</a>, <a href="/tags/import/">import</a>, <a href="/tags/custom-elements/">custom elements</a>
  </div>

        <!--
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>
-->
        <a class="bshareDiv" href="http://www.bshare.cn/share">分享按钮</a><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#uuid=c55eb60c-b08a-4141-9020-2b3128ca0cc6&style=11&bp=qqmb,bsharesync,sinaminiblog,qzone,sohuminiblog,renren,xinhuamb,tianya,shouji,ifengmb,neteasemb,qqxiaoyou,kaixin001,peoplemb,baiduhi,douban,qqim"></script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:suetming.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/android/">android</a><small>3</small></li>
  
    <li><a href="/categories/deep-learning/">deep learning</a><small>1</small></li>
  
    <li><a href="/categories/java/">java</a><small>1</small></li>
  
    <li><a href="/categories/javascript/">javascript</a><small>3</small></li>
  
    <li><a href="/categories/octopress/">octopress</a><small>1</small></li>
  
    <li><a href="/categories/虚拟货币/">虚拟货币</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/DDOS/" style="font-size: NaNpx;">DDOS</a><a href="/tags/Deep-Learning/" style="font-size: NaNpx;">Deep Learning</a><a href="/tags/IO-performance/" style="font-size: NaNpx;">I/O performance</a><a href="/tags/Scrolling-performance/" style="font-size: NaNpx;">Scrolling performance</a><a href="/tags/UI-performance/" style="font-size: NaNpx;">UI performance</a><a href="/tags/custom-elements/" style="font-size: NaNpx;">custom elements</a><a href="/tags/decorator/" style="font-size: NaNpx;">decorator</a><a href="/tags/free-bitcoin/" style="font-size: NaNpx;">free bitcoin</a><a href="/tags/import/" style="font-size: NaNpx;">import</a><a href="/tags/javascript/" style="font-size: NaNpx;">javascript</a><a href="/tags/seo/" style="font-size: NaNpx;">seo</a><a href="/tags/shadow-DOM/" style="font-size: NaNpx;">shadow DOM</a><a href="/tags/templates/" style="font-size: NaNpx;">templates</a><a href="/tags/人脸检测/" style="font-size: NaNpx;">人脸检测</a><a href="/tags/历史记录/" style="font-size: NaNpx;">历史记录</a><a href="/tags/悬浮窗/" style="font-size: NaNpx;">悬浮窗</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://worrydream.com/" title="Bret Victor">Bret Victor</a></li>
<li><a href="http://coolshell.cn/" title="酷壳">Cool Shell</a></li>
</ul>
</div>

  <div class="widget tag">
<h3 class="title">微信号</h3>
<img src="/images/photos/2013-08-11-code-weixin2.png" alt="微信" width="100%">
</div>

  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1651218572&verifier=80fcc888&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
 <script type="text/javascript">
  var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
  document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F5533780f373b71b5d7f93e710ff74bfc' type='text/javascript'%3E%3C/script%3E"));
 </script>
  
  &copy; 2014 suetming
  
</div>
<div class="clearfix"></div>
<!-- UJian Button BEGIN -->
<script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?type=slide&btn=4&fade=1&uid=1825970"></script>
<a href="http://www.ujian.cc" style="border:0;"><img src="http://img.ujian.cc/pixel.png" alt="友荐云推荐" style="border:0;padding:0;margin:0;" /></a>
<!-- UJian Button END -->
</footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>