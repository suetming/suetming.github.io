<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Web组件(Web Components) | HTML5 | 盖世小虫</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="译者：suetming
原文：W3C: Web Components
SuetMing 保留部分权力。基于“CC 3.0 BY-SA 协议”发布
1 关于本文
注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.这是一个迭代的过程
本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明">
<meta property="og:type" content="article">
<meta property="og:title" content="Web组件(Web Components) | HTML5">
<meta property="og:url" content="http://suetming.cn/2014/07/29/2013-06-29-web-components/">
<meta property="og:site_name" content="盖世小虫">
<meta property="og:description" content="译者：suetming
原文：W3C: Web Components
SuetMing 保留部分权力。基于“CC 3.0 BY-SA 协议”发布
1 关于本文
注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.这是一个迭代的过程
本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明">
<meta property="og:image" content="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-handler-registration.png">
<meta property="og:image" content="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-routing-retargeting.png">
<meta property="og:image" content="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg">
<meta property="og:image" content="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web组件(Web Components) | HTML5">
<meta name="twitter:description" content="译者：suetming
原文：W3C: Web Components
SuetMing 保留部分权力。基于“CC 3.0 BY-SA 协议”发布
1 关于本文
注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.这是一个迭代的过程
本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明">
  
    <link rel="alternative" href="/atom.xml" title="盖世小虫" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">盖世小虫</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://suetming.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2013-06-29-web-components" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/29/2013-06-29-web-components/" class="article-date">
  <time datetime="2014-07-29T14:15:17.000Z" itemprop="datePublished">7月 29 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Web组件(Web Components) | HTML5
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>译者：<a href="http://suetming.com" target="_blank" rel="external">suetming</a></p>
<p>原文：<a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/" target="_blank" rel="external">W3C: Web Components</a></p>
<p><strong>SuetMing 保留部分权力。基于“<a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="external">CC 3.0 BY-SA 协议</a>”发布</strong></p>
<h2 id="1_关于本文">1 关于本文</h2>
<p>注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.<br>这是一个迭代的过程</p>
<p>本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明</p>
<p><a id="more"></a></p>
<h2 id="2_介绍">2 介绍</h2>
<p>web组件模型由5部分组成：</p>
<ul>
<li>Templates：由一系列复用时能被激活的标记组成</li>
<li>Decorators：用于Templates中，通过CSS丰富和控制交互改变文本</li>
<li>Custom Elements：让用户可以自定义元素[自定义元素名、自定义API接口]</li>
<li>Shadow DOM：将一组DOM树封装成一个用户接口元素</li>
<li>Imports：定义如何将Templates、Decorators和Custom Elements打包，并且能够以资源的形式从外部引用</li>
</ul>
<p>每一部分都有各自的用途. 如果将这5种技术引入，开发人员可以轻松的编写拥有复杂交互体验的组件，并且可以轻松引用和组装，这是今天的CSS和脚本语言所无法达到的</p>
<p>本文将会讨论这5种技术，并举例说明其在Web组件中的作用</p>
<h2 id="3_Templates">3 Templates</h2>
<p>具体规范参加这篇<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html" target="_blank" rel="external">HTML Templates</a></p>
<p><strong>template</strong>元素及其所包含元素会由解析器进行解析并标记，不过不会立即渲染出来，脚本不会立即执行，包含的图片也不会立即下载</p>
<p><strong>template</strong>元素有一个属性 <strong>content</strong> 存储元素的实际内容，属性 <strong>content</strong> 的内容可以拷贝移动到HTML节点中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag"><<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"commentTemplate"</span>></span>
    <span class="tag"><<span class="title">div</span>></span>
        <span class="tag"><<span class="title">img</span> <span class="attribute">src</span>=<span class="value">""</span>></span>
        <span class="tag"><<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"comment-text"</span>></span><span class="tag"></<span class="title">div</span>></span>
    <span class="tag"></<span class="title">div</span>></span>
<span class="tag"></<span class="title">template</span>></span>
<span class="tag"><<span class="title">script</span>></span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">addComment</span><span class="params">(imageUrl, text)</span> {</span>
  <span class="keyword">var</span> t = document.querySelector(<span class="string">"#commentTemplate"</span>);
  <span class="keyword">var</span> comment = t.content.cloneNode(<span class="literal">true</span>);
  <span class="comment">// Populate content.</span>
  comment.querySelector(<span class="string">'img'</span>).src = imageUrl;
  comment.querySelector(<span class="string">'.comment-text'</span>).textContent = text;
  document.body.appendChild(comment);
}
</span><span class="tag"></<span class="title">script</span>></span>
</pre></td></tr></table></figure>

<p><strong>template</strong> 所包含的的元素包含在属性 <strong>content</strong> 中，通过script拷贝里面的元素并插入到HTML中使图片加载进来，脚本开始运行. 例如，在templates引入大型脚本，需要时调用</p>
<h2 id="4_Decorators">4 Decorators</h2>
<p>Decorators 目前没有标准文档，<strong>decorator</strong> 主要加强或者重载已经存在的元素，由CSS控制表现，与一般元素不同的是通过标记可以达到额外的效果</p>
<p><strong>decorator</strong>通过包含<strong>template</strong>来明确具体渲染哪一块</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag"><<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>></span>
    <span class="tag"><<span class="title">template</span>></span>
        <span class="tag"><<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>></span>
          ▾
          <span class="tag"><<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"summary"</span>></span><span class="tag"></<span class="title">content</span>></span>
        <span class="tag"></<span class="title">a</span>></span>
        <span class="tag"><<span class="title">content</span>></span><span class="tag"></<span class="title">content</span>></span>
    <span class="tag"></<span class="title">template</span>></span>
<span class="tag"></<span class="title">decorator</span>></span>
</pre></td></tr></table></figure>

<p><strong>content</strong>包含待渲染的内容，通过CSS控制生效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">details</span><span class="attr_selector">[open]</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-open)</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>通过这种方式可以使下面的html代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag"><<span class="title">details</span> <span class="attribute">open</span>></span>
    <span class="tag"><<span class="title">summary</span>></span>Timepieces<span class="tag"></<span class="title">summary</span>></span>
    <span class="tag"><<span class="title">ul</span>></span>
      <span class="tag"><<span class="title">li</span>></span>Sundial
      <span class="tag"><<span class="title">li</span>></span>Cuckoo clock
      <span class="tag"><<span class="title">li</span>></span>Wristwatch
    <span class="tag"></<span class="title">ul</span>></span>
<span class="tag"></<span class="title">details</span>></span>
</pre></td></tr></table></figure>

<p>最终渲染成</p>
<p><a><br>  ▾ Timepieces<br></a></p>
<ul><br>  <li>Sundial<br>  </li><li>Cuckoo clock<br>  </li><li>Wristwatch<br></li></ul>


<p><strong>decorator</strong> CSS属性可以指向任何网络资源，不过只有其“定义”被调用才能申请，生成的标记仅限于展示，永远不会运行脚本包括内联事件，而且也是不可编辑的</p>
<p>4.1 Decorators的事件</p>
<p>Decorators可以关联事件增强交互，decorator采用事件控制器当做媒介，因为decorator可能在任何时间生效或者失效，所以关联template中监听节点事件或者获取其状态都是无效的</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-handler-registration.png" alt="事件注册"></p>
<p>通过事件控制器注册事件监听器，template中插入<strong>script</strong>，decorator元素插入到文档中时脚本会执行，脚本会被插入到注册队列中:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
<span class="tag"><<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>></span>
    <span class="tag"><<span class="title">script</span>></span><span class="javascript">
        <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">(event)</span> {</span>
            event.target.removeAttribute(<span class="string">'open'</span>);
        }
        [{selector: <span class="string">'#summary'</span>, type: <span class="string">'click'</span>, handler: clicked}];
    </span><span class="tag"></<span class="title">script</span>></span>
    <span class="tag"><<span class="title">template</span>></span>
      <span class="tag"><<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>></span>
        <span class="comment"><!-- as illustrated above --></span>
      <span class="tag"></<span class="title">a</span>></span>
    <span class="tag"></<span class="title">template</span>></span>
<span class="tag"></<span class="title">decorator</span>></span>
</pre></td></tr></table></figure>

<p>事件控制器解析注册事件如图所示</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-routing-retargeting.png" alt="事件的路由和重定向"></p>
<p>事件监听器被调用时，事件的目标是最终生成的内容而不是template中的内容. 点击template中定义的▾，将会调用单击事件（在template中定义的<strong>#summary</strong>元素）, event.target指向<strong>details</strong>，事件的重定向不会影响文档DOM结构</p>
<p>移除属性<strong>open</strong>，由于selector与decorator的属性不匹配，这个decorator不再有效. 未应用的decorator会回到最初的状态. 不过可以再构造一个decorator来渲染<strong>closed</strong>，通过激活不同的decorator可以达到无状态交互，代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="tag"><<span class="title">style</span>></span><span class="css">
<span class="tag">details</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-closed)</span></span></span>;
<span class="rule">}</span></span>
<span class="tag">details</span><span class="attr_selector">[open]</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-open)</span></span></span>;
<span class="rule">}</span></span>
</span><span class="tag"></<span class="title">style</span>></span>

<span class="tag"><<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-closed"</span>></span>
    <span class="tag"><<span class="title">script</span>></span><span class="javascript">
        <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">(event)</span> {</span>
            event.target.setAttribute(<span class="string">'open'</span>, <span class="string">'open'</span>);
        }
        [{selector: <span class="string">'#summary'</span>, type: <span class="string">'click'</span>, handler: clicked}];
    </span><span class="tag"></<span class="title">script</span>></span>
    <span class="tag"><<span class="title">template</span>></span>
        <span class="tag"><<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>></span>
            ▸ <span class="tag"><<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"summary"</span>></span><span class="tag"></<span class="title">content</span>></span>
        <span class="tag"></<span class="title">a</span>></span>
    <span class="tag"></<span class="title">template</span>></span>
<span class="tag"></<span class="title">decorator</span>></span>

<span class="tag"><<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>></span>
    <span class="comment"><!-- as illustrated above --></span>
<span class="tag"></<span class="title">decorator</span>></span>
</pre></td></tr></table></figure>

<h2 id="5_Custom_Elements">5 Custom Elements</h2>
<p>技术规范见此<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html" target="_blank" rel="external">The Custom Elements specification</a></p>
<p>用户可以构造新的DOM元素，这种技术称之为Custom Elements. 不像decorators，自定义元素可以封装状态并提供脚本接口. 下面的数据表表明两者区别</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="tag"><<span class="title">blockquote</span>></span>
<span class="tag"><<span class="title">table</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span><span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Decorators<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Custom Elements<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Lifetime<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Ephemeral, while a CSS selector matches<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Stable, matches entire element lifetime<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Applied, unapplied dynamically<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Yes, based on CSS selectors<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>No, fixed at element creation time<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Accessible through script<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>No, transparent to DOM; cannot add interfaces<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Yes, accessible through DOM; can provide interfaces<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span>State<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Stateless projection<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Stateful DOM object<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
   <span class="tag"><<span class="title">tr</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Behavior<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>Simulated by changing decorators<span class="tag"></<span class="title">td</span>></span>
      <span class="tag"><<span class="title">td</span>></span>First-class using script and events<span class="tag"></<span class="title">td</span>></span>
   <span class="tag"></<span class="title">tr</span>></span>
<span class="tag"></<span class="title">table</span>></span>
<span class="tag"></<span class="title">blockquote</span>></span>
</pre></td></tr></table></figure>

<h2 id="5-1_构造一个自定义元素">5.1 构造一个自定义元素</h2>
<p>用<strong>element</strong>构造一个元素，并指明继承哪一个属性如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag"><<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"button"</span> <span class="attribute">name</span>=<span class="value">"fancy-button"</span>></span>
    …
<span class="tag"></<span class="title">element</span>></span>
</pre></td></tr></table></figure>

<p><strong>extends</strong>属性标记继承于哪一个元素，自定义元素实例会有此标记名</p>
<p><strong>name</strong>属性指明元素名称，命名必须包含“-”</p>
<p>用户的自定义元素应该继承最接近自己想法的实际存在的元素. 如果用户构造不继承任何元素的自定义元素，user agent会抛出异常<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#htmlunknownelement" target="_blank" rel="external">HTMLUnknownElement</a></p>
<h2 id="5-2_方法和属性">5.2 方法和属性</h2>
<p>将<strong>script</strong>插入到自定义元素中可以对自定义元素增加方法和属性，下面的例子中元素<strong>tick-tock-clock</strong>增加了tick方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag"><<span class="title">element</span> <span class="attribute">name</span>=<span class="value">"tick-tock-clock"</span>></span>
  <span class="tag"><<span class="title">script</span>></span><span class="javascript">
    ({
      tick: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        …
      }
    });
  </span><span class="tag"></<span class="title">script</span>></span>
<span class="tag"></<span class="title">element</span>></span>
</pre></td></tr></table></figure>

<p>5.3 生命周期回调函数<br>自定义元素有很多回调函数如下：</p>
<ul>
<li>readyCallback：创建时调用</li>
<li>insertedCallback：插入文档时调用</li>
<li>removedCallbakc：删除元素时调用</li>
</ul>
<p>下面的例子演示如何用template，Shadow DOM (见下一章节)，以及Custom Elements回调函数创建元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="tag"><<span class="title">element</span> <span class="attribute">name</span>=<span class="value">"tick-tock-clock"</span>></span>
  <span class="tag"><<span class="title">template</span>></span>
    <span class="tag"><<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"hh"</span>></span><span class="tag"></<span class="title">span</span>></span>
    <span class="tag"><<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"sep"</span>></span>:<span class="tag"></<span class="title">span</span>></span>
    <span class="tag"><<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"mm"</span>></span><span class="tag"></<span class="title">span</span>></span>
  <span class="tag"></<span class="title">template</span>></span>
  <span class="tag"><<span class="title">script</span>></span><span class="javascript">
    <span class="keyword">var</span> template = document.currentScript.parentNode.querySelector(<span class="string">'template'</span>);

    <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> {</span>
      <span class="keyword">this</span>.tick();
      <span class="keyword">this</span>._interval = window.setInterval(<span class="keyword">this</span>.tick.bind(<span class="keyword">this</span>), <span class="number">1000</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> {</span>
      window.clearInterval(<span class="keyword">this</span>._interval);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">fmt</span><span class="params">(n)</span> {</span>
      <span class="keyword">return</span> (n < <span class="number">10</span> ? <span class="string">'0'</span> : <span class="string">''</span>) + n;
    }

    ({
      readyCallback: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>._root = <span class="keyword">this</span>.createShadowRoot();
        <span class="keyword">this</span>._root.appendChild(template.content.cloneNode());
        <span class="keyword">if</span> (<span class="keyword">this</span>.parentElement) {
          start.call(<span class="keyword">this</span>);
        }
      },
      insertedCallback: start,
      removedCallback: stop,
      tick: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();
        <span class="keyword">this</span>._root.querySelector(<span class="string">'hh'</span>).textContent = fmt(now.getHours());
        <span class="keyword">this</span>._root.querySelector(<span class="string">'sep'</span>).style.visibility =
            now.getSeconds() % <span class="number">2</span> ? <span class="string">'visible'</span> : <span class="string">'hidden'</span>;
        <span class="keyword">this</span>._root.querySelector(<span class="string">'mm'</span>).textContent = fmt(now.getMinutes());
      },
      chime: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … }
    });
  </span><span class="tag"></<span class="title">script</span>></span>
<span class="tag"></<span class="title">element</span>></span>
</pre></td></tr></table></figure>

<p>5.4 Custom Elements实例化<br>自定义元素均继承HTML的标准元素(div/button/option/…)， 当用户想用这些元素的时候需要用到属性<strong>is</strong>，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag"><<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"button"</span> <span class="attribute">name</span>=<span class="value">"fancy-button"</span>></span>  <span class="comment"><!-- definition --></span>
    …
<span class="tag"></<span class="title">element</span>></span>

<span class="tag"><<span class="title">button</span> <span class="attribute">is</span>=<span class="value">"fancy-button"</span>></span>  <span class="comment"><!-- use --></span>
    Do something fancy
<span class="tag"></<span class="title">button</span>></span>
</pre></td></tr></table></figure>

<p>5.5 Script实例化Custom Elements<br>通过脚本语言也可以实例化自定义元素，方法为<strong>register</strong>，具体见下述代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(HTMLButtonElement.prototype, {});
p.dazzle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … };

<span class="comment">// 返回实例化对象</span>
<span class="keyword">var</span> FancyButton = document.register(<span class="string">'button'</span>, <span class="string">'fancy-button'</span>, {prototype: p});
<span class="keyword">var</span> b = <span class="keyword">new</span> FancyButton();
document.body.appendChild(b);
b.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
    event.target.dazzle();
});
</pre></td></tr></table></figure>

<p>也可以直接通过createElement生成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> b = document.createElement(<span class="string">'button'</span>, <span class="string">'fancy-button'</span>);
alert(b.outerHTML); <span class="comment">// will display '<button is="fancy-button"></button>'</span>
<span class="keyword">var</span> c = document.createElement(<span class="string">'tick-tock-clock'</span>);
alert(c.outerHTML); <span class="comment">// will display '<tick-tock-clock></tick-tock-clock>'</span>
</pre></td></tr></table></figure>

<h2 id="5-6_元素更新">5.6 元素更新</h2>
<p>当元素定义调用的时候，每一个匹配的元素都会进行更新. 更新元素后，元素相应API会生效，生命周期相关函数会被调用.<br>通过CSS<strong>:unresolved</strong>可以匹配所有为构造的自定义元素，通过这种方式避免更新元素所造成的闪烁</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag"><<span class="title">style</span>></span><span class="css">
<span class="tag">tick-tock-clock</span><span class="pseudo">:unresolved</span> <span class="rules">{
  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">'??:??'</span></span></span>;  
<span class="rule">}</span></span>
</span><span class="tag"></<span class="title">style</span>></span>
<span class="tag"><<span class="title">tick-tock-clock</span>></span><span class="tag"></<span class="title">tick-tock-clock</span>></span> <span class="comment"><!-- will show ??:?? --></span>
</pre></td></tr></table></figure>

<p>也可以通过脚本进行控制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// Chime ALL the clocks!</span>
<span class="built_in">Array</span>.prototype.forEach.call(
  document.querySelectorAll(<span class="string">'tick-tock-clock:not(:unresolved)'</span>),
  <span class="function"><span class="keyword">function</span> <span class="params">(clock)</span> {</span> clock.chime(); });
</pre></td></tr></table></figure><br>通过自定义事件元素可以通知页面其他部分元素已经更新，可以等到元素更新完成，脚本在对其进行操作<br><br>5.7 扩展Custom Elements<br>元素也可以继承自定义元素，代码如下：<br><br><figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag"><<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"tick-tock-clock"</span> <span class="attribute">name</span>=<span class="value">"grand-father-clock"</span>></span>
    …
<span class="tag"></<span class="title">element</span>></span>
<span class="tag"><<span class="title">script</span>></span><span class="javascript">
<span class="keyword">var</span> p = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(document.createElement(<span class="string">'tick-tock-clock'</span>)));
p.popOutBirdie = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … }
<span class="keyword">var</span> CuckooClock = document.register(<span class="string">'cuckoo-clock'</span>, {prototype: p});
<span class="keyword">var</span> c = <span class="keyword">new</span> CuckooClock();
c.tick();         <span class="comment">// inherited from tick-tock-clock</span>
c.popOutBirdie(); <span class="comment">// specific to cuckoo-clock</span>
</span><span class="tag"></<span class="title">script</span>></span>
</pre></td></tr></table></figure>

<h2 id="6_Shadow_DOM">6 Shadow DOM</h2>
<p>相应规范见这里<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html" target="_blank" rel="external">The Shadow DOM specification</a></p>
<p>Shadow DOM 是一种DOM节点的辅助树. Shadow DOM 子树能够关联某个元素，但不会显示在元素子节点中，子树有自己的作用域. 例如，一个shadow DOM 子树可以和文档中相同ID和风格的元素而不冲突，因为shadow DOM 子树与文档是完全分离的</p>
<p>Shadow DOM 通过<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#api-partial-element-create-shadow-root" target="_blank" rel="external"><strong>createShadowRoot</strong></a>方法生效，返回shadow DOM的根节点并填充到DOM节点中</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg" alt="shadow trees"></p>
<object data="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg" width="800" height="430"></object>

<p>关联shadow DOM的元素称为<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-shadow-host" target="_blank" rel="external">shadow host</a>. 当元素存在shadow DOM，元素的子节点不会渲染；渲染的是shadow DOM的内容</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg" alt="shadow rendering"></p>
<object data="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg" width="450" height="400"></object>

<p>6.1 插入点<br>shadow DOM 子树通过<figure class="highlight <content>```元素作为渲染输出插入点."><figcaption><span>```<content>```只是作为渲染输出的插入点，如下：</content></span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html<br><!-- document --></p>
<div id="news"><br>  <h1>Good day for kittens</h1><br>  <div class="breaking">Kitten rescued from tree</div><br>  <div>Area kitten “adorable”—owner</div><br>  <div class="breaking">Jiggled piece of yarn derails kitten kongress</div><br></div>

<p><!-- #news' shadow --></p>
<template id="t"><br>  <content select="h1"></content><br>  <div id="ticker"><br>    <content id="stories"></content><br>  </div><br></template>

<p><!-- #ticker's shadow --></p>
<template id="u"><br>  <content class="highlight" select=".breaking"></content><br>  <content></content><br></template>

<script>
// Set up shadow DOM
var news = document.querySelector('#news');
var r = news.createShadowRoot();
var t = document.querySelector('#t');
r.appendChild(t.content.cloneNode(true));

var ticker = r.querySelector('#ticker');
var s = ticker.createShadowRoot();
var u = document.querySelector('#u');
s.appendChild(u.content.cloneNode(true));
</script>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
理论上，第一部分文档和第一部分<span class="built_in">shadow</span>根节点生成了下面的DOM树. 宿主元素的子节点显示在插入点的位置.
</pre></td></tr></table></figure>html
<div id="news">
  <h1>Good day for kittens</h1>
  <div id="ticker">
    <div class="breaking">Kitten rescued from tree</div>
    <div>Area kitten "adorable"—owner</div>
    <div class="breaking">Jiggled piece of yarn derails kitten kongress</div>
  </div>
</div>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
第二部分，由于
</pre></td></tr></table></figure><content class="highlight" select=".breaking"><figure class="highlight 所有类属性为breaking的排在顶部，这种方式称为[reprojection](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#reprojection)"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html
<div id="news">
  <h1>Good day for kittens</h1>
  <div id="ticker">
    <div class="breaking">Kitten rescued from tree</div>
    <div class="breaking">Jiggled piece of yarn derails kitten kongress</div>
    <div>Area kitten "adorable"—owner</div>
  </div>
</div>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
6.3 备用内容
插入点可以有<span class="emphasis">_content_</span>，称为[<span class="link_label">备用内容</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-fallback-content</span>)，当插入点没有任何文本时，会显示此信息，如下：
</pre></td></tr></table></figure>html
<!-- #news' shadow -->
<template id="t">
  <content select="h1">Today's top headlines</content>
  <div id="ticker">
    <content id="stories">
      No news
      <button onclick="window.location.reload(true);">Reload</button>
    </content>
  </div>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="header">6.4 多重Shadow子树
---------------------------</span>
一个元素可以含有不止一个shadow DOM 子树. 继承一个已具有shadow DOM子树的自定义元素是很常见的. 不过要是想重用原先的元素时怎么处理? 如何重用?
利用
</pre></td></tr></table></figure><shadow><figure class="highlight 可以调用原先申请的shadow"><figcaption><span>DOM 子树，如下：</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>html
<element name="sailing-watch" extends="tick-tock-clock">
  <template>
    <shadow></shadow>
    <div id="compass">N</div>
  </template>
  <script>
    …
  </script>
</element>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>
由于一个元素可以有多个shadow，我们需要了解这些shadow如何相互影响，如何作用元素的子节点

由于你不能删除shadow root，所以shadow DOM子树生效时的顺序很重要，如下：

-<span class="ruby"> <span class="number">1</span>. user agent shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">2</span>. 自定义元素的shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">3</span>. 第一个派生自定义元素的shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">4</span>. ...
</span>-<span class="ruby"> <span class="number">5</span>. 用脚本添加的<span class="constant">Ad</span>-hoc shadow <span class="constant">DOM</span>
</span>-<span class="ruby"> <span class="number">6</span>. <span class="constant">Decorator</span> shadow (applied <span class="keyword">and</span> removed with <span class="constant">CSS</span> rules—<span class="keyword">not</span> technically shadow <span class="constant">DOM</span>, but its insertion points work similarly to shadow <span class="constant">DOM</span>.)
</span>
其次，根据顺序从最新生效的子树反向推倒，每一个
</pre></td></tr></table></figure><content><figure class="highlight 插入点，根据规则，可以定位任何宿主元素子节点"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
一旦子节点在正确的地方渲染，我们可以检查是否有
</pre></td></tr></table></figure><shadow><figure class="highlight 元素，如果没有，表明成功；如果有，从```<shadow>```队列元素中取出子树重复替换```<content>```插入点，直到队尾."><figcaption><span>具体见如下图：</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>
![<span class="link_label">shadow stack</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg</span>)

<span class="xml"><span class="tag"><<span class="title">object</span> <span class="attribute">data</span>=<span class="value">"https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg"</span> <span class="attribute">width</span>=<span class="value">"500"</span> <span class="attribute">height</span>=<span class="value">"600"</span>></span></span><span class="xml"><span class="tag"></<span class="title">object</span>></span></span>

总结一下：

<span class="bullet">- </span>最近申请的shadow DOM 子树最可能在
</pre></td></tr></table></figure><content><figure class="highlight 插入点获得最新的子树"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>-<span class="ruby"> 以此类推
</span>-<span class="ruby"> 直到当前的shadow <span class="constant">DOM</span>子树没有</span>
</pre></td></tr></table></figure><shadow><figure class="highlight ，那么其就是这个元素最后的DOM子树"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
<span class="header">6.5 CSS 和 Shadow DOM
-------------------------------------</span>
当构建自定义元素时自然要考虑属性、内容和API接口. 这与页面渲染同等重要. Shadow DOM 提供给开发者很多方式控制shadow DOM内容的样式.

shadow DOM 子树有一个不看见的边界，user agent的样式默认生效，而不是定制的样式. 派生的元素依旧有效，这不是我们想要的. 在上面的scailing-watch的例子里，如果页面内容被渲染成绿色，如果要保持整体风格，shadow DOM内的文本由于color属性由于继承性质也会是绿色，不过设定了所有
</pre></td></tr></table></figure><div><figure class="highlight 元素橙色边框，"><figcaption><span>那direction indicator不会有橙色边框因为__border__并不是具有继承性质的属性</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
一个shadow根节点有两个属性控制行为. applyAuthorStyles（开发者样式）属性，shadow DOM 会匹配最接近的样式，注意这个属性只能匹配shadow DOM 子树. 使用时要注意"n"代选择器

如果<span class="strong">__applyAuthorStyles__</span>设置为false，<span class="strong">__resetStyleInheritance__</span>设置为true，样式会清空. 元素会被与页面样式隔离，你可以通过浏览器重置样式

在插入点有相似的界限. shadow DOM子树的样式不会再插入点分布的元素上生效. 不过要是通过选择器想渲染某一部分特定内容， 可以用[<span class="link_label">::distributed pseudo-selector</span>](<span class="link_url">https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#distributed-pseudo-element</span>)，如下：
</pre></td></tr></table></figure>html
<!-- #ticker's shadow -->
<template id="u">
  <style>
    content::distributed(*) {
      display: inline-block;
    }
    *::distributed(.breaking) {
      text-shadow: 0 0 0.2em maroon;
      color: orange;
    }
  </style>
  <content class="highlight" select=".breaking"></content>
  <content></content>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
上述包含了两个规则，选择器的左半部分是<span class="built_in">shadow</span> DOM 生效；括号内代表适用元素。第一个选择器对
</pre></td></tr></table></figure><content><figure class="highlight 的所有元素有效；第二个选择器对类对象为breaking的元素有效"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
ShadowDOM 也可以定制宿主元素的样式. 代码如下：
</pre></td></tr></table></figure>html
<!-- #ticker's shadow -->
<template id="u">
  <style>
    @host {
      :scope {
        white-space: nowrap;
        overflow-style: marquee-line;
        overflow-x: marquee;
      }
    }
    content::distributed(*) {
      display: inline-block;
    }
    *::distributed(.breaking) {
      text-shadow: 0 0 0.2em maroon;
      color: orange;
    }
  </style>
  <content class="highlight" select=".breaking"></content>
  <content></content>
</template>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
最后，有两种方式可以使<span class="built_in">shadow</span> DOM 子树的样式与页面保持一致. 首先通过分配一个伪ID暴漏<span class="built_in">shadow</span> DOM 子树中的特定元素，开发者可以定制其样式. 例如：
</pre></td></tr></table></figure>html
<script>
// Set up shadow DOM
…
var ticker = r.querySelector('#ticker');
ticker.pseudo = 'x-ticker';
…
</script>

<p><!-- change the appearance of the ticker part --></p>
<p><style></p>
<h1 id="news::x-ticker_{">news::x-ticker {</h1>
<p>  background: gray;<br>  color: lightblue;<br>}<br></style></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
另一种方法是通过CSS变量进行控制，如下：
</pre></td></tr></table></figure>html<br><!-- #ticker's shadow --></p>
<template id="u"><br>  <style><br>    @host {<br>      :scope {<br>        white-space: nowrap;<br>        overflow-style: marquee-line;<br>        overflow-x: marquee;<br>      }<br>    }<br>    content::distributed(<em>) {<br>      display: inline-block;<br>    }
    </em>::distributed(.breaking) {<br>      text-shadow: 0 0 0.2em var(highlight-accent, maroon);<br>      color: var(highlight-primary, orange);<br>    }<br>  </style><br>  <content class="highlight" select=".breaking"></content><br>  <content></content><br></template>

<p><!-- change the appearance of the ticker part --></p>
<p><style></p>
<h1 id="news::x-ticker_{-1">news::x-ticker {</h1>
<p>  background: gray;<br>  color: lightblue;<br>  var-highlight-primary: green;<br>  var-highlight-accent: yellow;<br>}<br></style></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
伪元素方法针对特定元素保持页面样式非常有用，而CSS变量则对不想重复指定的属性集（主题风格）非常有用. 

<span class="header">6.6 Shadow DOM中的事件
----------------------------------------</span>
为了确保shadow DOM子树中的元素不会暴露给外部子树，会有很多工作来分发内部子树事件. 
首先，shadow DOM 子树会阻止事件如mutation和selectstart外部监听. 那些能够穿过shadow DOM的范围并且重定向的的事件，它们的_<span class="emphasis">_target_</span><span class="emphasis">_和_</span><span class="emphasis">_relatedTarget_</span><span class="emphasis">_的会指向shadow DOM子树的宿主元素. 在一些情况下，如_</span><span class="emphasis">_DOMFocusIn_</span><span class="emphasis">_，_</span><span class="emphasis">_mouseover_</span><span class="emphasis">_，_</span><span class="emphasis">_mouseout_</span><span class="emphasis">_事件需要特别注意，如果你在shadow DOM的两个元素中间移动鼠标，会出现鼠标从本身移动到它本身这种诡异的事件

</span>
<span class="header">7 Imports
----------------------------------------</span>
规范标准见这里[The HTML Imports specification](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html)

Custom elements 和 decorators可以通过文件的方式引入：
</pre></td></tr></table></figure>html</p>
<p><link rel="import" href="goodies.html"></p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
只有
</pre></td></tr></table></figure><decorator><code>元素和</code><element>```能被user agent解析，脚本也可以通过<strong>import</strong>属性获取DOM.  跨域检索的文档可以通过CORS判定这些定义是否可以跨站运行. </element></decorator></p>
</content></div></shadow></content></shadow></content></shadow></content>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://suetming.cn/2014/07/29/2013-06-29-web-components/" data-id="j8vexmulxjw97zdt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/custom-elements/">custom elements</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/decorator/">decorator</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/import/">import</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shadow-DOM/">shadow DOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/templates/">templates</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2014/06/28/仿360chathead等app悬浮窗效果/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">仿360|ChatHead等APP悬浮窗和动画效果</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/deep-learning/">deep learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/octopress/">octopress</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟货币/">虚拟货币</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDOS/">DDOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deep-Learning/">Deep Learning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO-performance/">I/O performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrolling-performance/">Scrolling performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI-performance/">UI performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-elements/">custom elements</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decorator/">decorator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/free-bitcoin/">free bitcoin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/import/">import</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/seo/">seo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadow-DOM/">shadow DOM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/templates/">templates</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人脸检测/">人脸检测</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史记录/">历史记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/悬浮窗/">悬浮窗</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DDOS/" style="font-size: NaNpx;">DDOS</a><a href="/tags/Deep-Learning/" style="font-size: NaNpx;">Deep Learning</a><a href="/tags/IO-performance/" style="font-size: NaNpx;">I/O performance</a><a href="/tags/Scrolling-performance/" style="font-size: NaNpx;">Scrolling performance</a><a href="/tags/UI-performance/" style="font-size: NaNpx;">UI performance</a><a href="/tags/custom-elements/" style="font-size: NaNpx;">custom elements</a><a href="/tags/decorator/" style="font-size: NaNpx;">decorator</a><a href="/tags/free-bitcoin/" style="font-size: NaNpx;">free bitcoin</a><a href="/tags/import/" style="font-size: NaNpx;">import</a><a href="/tags/javascript/" style="font-size: NaNpx;">javascript</a><a href="/tags/seo/" style="font-size: NaNpx;">seo</a><a href="/tags/shadow-DOM/" style="font-size: NaNpx;">shadow DOM</a><a href="/tags/templates/" style="font-size: NaNpx;">templates</a><a href="/tags/人脸检测/" style="font-size: NaNpx;">人脸检测</a><a href="/tags/历史记录/" style="font-size: NaNpx;">历史记录</a><a href="/tags/悬浮窗/" style="font-size: NaNpx;">悬浮窗</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">七月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06">六月 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08">八月 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/07/29/2013-06-29-web-components/">Web组件(Web Components) | HTML5</a>
          </li>
        
          <li>
            <a href="/2014/06/28/仿360chathead等app悬浮窗效果/">仿360|ChatHead等APP悬浮窗和动画效果</a>
          </li>
        
          <li>
            <a href="/2014/06/28/2013-07-13-android-performance/">android深度优化</a>
          </li>
        
          <li>
            <a href="/2014/06/28/2013-06-23-overwrite-global-methods/">重写全局方法 | JavaScript</a>
          </li>
        
          <li>
            <a href="/2014/06/28/2013-06-08-capture-back-menu-with-history-api/">利用history api截获返回事件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 suetming<br>
      Powered by <a href="https://github.com/suetming" target="_blank">Suetming</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>